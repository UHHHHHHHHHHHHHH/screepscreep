"use strict";function e(e){var o,r;const t=null!==(r=null===(o=e.controller)||void 0===o?void 0:o.level)&&void 0!==r?r:0;if(t<2)return 1;if(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length<5)return 2;return e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length<e.find(FIND_SOURCES).length?2.5:t}function o(o){const r=e(o),t=o.find(FIND_CONSTRUCTION_SITES).length,n=2*o.find(FIND_SOURCES).length,s=Object.values(Game.creeps).filter((e=>"harvester"===e.memory.role&&e.room.name===o.name)).length;switch(r){case 1:return{harvester:n,builder:0,upgrader:s>=n?1:0};case 2:case 2.5:return{harvester:n,builder:s>=n&&t>0?1:0,upgrader:0};default:return{harvester:n,builder:t>0?1:0,upgrader:t>0?0:1}}}Object.defineProperty(exports,"__esModule",{value:!0});const r={harvester:{work:3,carry:1,move:1},builder:{work:1,carry:2,move:2},upgrader:{work:2,carry:2,move:1}};const t=[WORK,CARRY,CARRY,MOVE,MOVE];function n(e,o){const n=r[e];if(!n)return t;const s=function(e,o,r={work:100,carry:50,move:50}){const t=[],n=[];for(const o in e){const r=e[o];for(let e=0;e<r;e++)n.push(o)}const s=n.reduce(((e,o)=>e+r[o]),0),c=Math.floor(o/s),l=Math.min(c*n.length,50);for(let e=0;e<l;e++)t.push(n[e%n.length]);return t}(n,o);return s.length>0?s:t}function s(e){const o={work:0,carry:0,move:0,attack:0,ranged_attack:0,tough:0,heal:0,claim:0};for(const r of e)o[r]++;return Object.entries(o).filter((([e,o])=>o>0)).map((([e,o])=>`${o}${e[0]}`)).join("")}function c(e){const o=e.find(FIND_SOURCES),r={};for(const e of o)r[e.id]=0;for(const e of Object.values(Game.creeps))"harvester"===e.memory.role&&e.memory.sourceId&&(r[e.memory.sourceId]=(r[e.memory.sourceId]||0)+1);const t=o.find((e=>r[e.id]<2));return(null==t?void 0:t.id)||null}const l=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function i(o){switch(e(o)){case 2:!function(e){const o=e.controller;if(!o||!o.my||o.level<2)return;const r=CONTROLLER_STRUCTURES.extension[o.level],t=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,n=e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,s=r-(t+n);if(s<=0)return;const c=e.find(FIND_MY_SPAWNS)[0];if(!c)return;let i=0;for(const[o,r]of l){if(i>=s)return;const t=c.pos.x+o,n=c.pos.y+r;if(!(e.lookForAt(LOOK_STRUCTURES,t,n).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,t,n).length>0)){e.createConstructionSite(t,n,STRUCTURE_EXTENSION)===OK&&i++}}}(o);break;case 2.5:!function(e){const o=e.find(FIND_SOURCES);for(const r of o){const o=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.pos.inRangeTo(r.pos,1)}).length>0,t=e.find(FIND_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.pos.inRangeTo(r.pos,1)}).length>0;if(o||t)continue;const n=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];for(const[o,t]of n){const n=r.pos.x+o,s=r.pos.y+t;if("wall"===e.lookForAt(LOOK_TERRAIN,n,s)[0])continue;if(!(e.lookForAt(LOOK_STRUCTURES,n,s).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,n,s).length>0)){e.createConstructionSite(n,s,STRUCTURE_CONTAINER)===OK&&console.log(`📦 Placed container near ${r.id} at (${n}, ${s})`);break}}}}(o)}}class a{collectEnergy(e){if(Object.values(Game.creeps).some((e=>"harvester"===e.memory.role))){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}const o=e.room.find(FIND_SOURCES);o.length>0&&e.harvest(o[0])===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}updateWorkingState(e){e.memory.working&&0===e.store[RESOURCE_ENERGY]&&(e.memory.working=!1),e.memory.working||0!==e.store.getFreeCapacity()||(e.memory.working=!0)}}function m(e,o){const r=n(o,e.room.energyCapacityAvailable),t=e.body.map((e=>e.type)),s=new Set(r);for(const e of s)if(!t.includes(e))return!1;return!0}const u={upgrader:new class extends a{run(e){this.updateWorkingState(e),e.memory.working?e.upgradeController(e.room.controller)===ERR_NOT_IN_RANGE&&e.moveTo(e.room.controller):this.collectEnergy(e)}},builder:new class extends a{run(e){this.updateWorkingState(e),e.memory.working?this.build(e):this.collectEnergy(e)}build(e){const o=e.room.find(FIND_CONSTRUCTION_SITES);if(0===o.length){const o=e.room.find(FIND_MY_SPAWNS)[0];return void(o&&e.moveTo(o))}const r=e.pos.findClosestByRange(o);r&&e.build(r)===ERR_NOT_IN_RANGE&&e.moveTo(r)}},harvester:new class extends a{run(e){this.updateWorkingState(e),e.memory.working?this.deliverEnergy(e):this.harvest(e)}deliverEnergy(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});o.length>0&&e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}harvest(e){const o=e.memory.sourceId;let r=o?Game.getObjectById(o):null;if(!r){if(r=e.pos.findClosestByPath(FIND_SOURCES),!r)return void e.say("❓ no src");e.memory.sourceId=r.id,e.say("🔁")}e.harvest(r)===ERR_NOT_IN_RANGE&&e.moveTo(r)}}};exports.loop=function(){var e;!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`🧹 Cleaned up memory for dead creep: ${e}`))}(),function(){if(Game.time%10==0)for(const e of Object.values(Game.rooms)){const r=o(e);for(const e of Object.keys(r)){const o=r[e],t=Object.values(Game.creeps).filter((o=>o.memory.role!==e&&(!o.memory.lockUntil||Game.time>=o.memory.lockUntil)&&m(o,e))),n={harvester:0,upgrader:0,builder:0};for(const e of Object.values(Game.creeps))n[e.memory.role]=(n[e.memory.role]||0)+1;if(n[e]>=o)continue;const s=t.find((e=>{var o;const t=n[e.memory.role],s=null!==(o=r[e.memory.role])&&void 0!==o?o:0;return 0===s||t>s}));if(s){console.log(`🔁 ${s.name}: ${s.memory.role} → ${e}`),s.memory.role=e,s.memory.lockUntil=Game.time+100;break}console.log(`⚠️ No reassignable creeps found for role '${e}'`),console.log(`  Needed: ${o}, Current: ${n[e]}`),console.log("  Candidates:",t.map((e=>`${e.name} (${e.memory.role})`)))}}}();const r=Object.values(Game.spawns)[0];r&&function(e){const r=o(e.room);if(0===Object.values(Game.creeps).filter((e=>"harvester"===e.memory.role)).length&&e.store[RESOURCE_ENERGY]>=200){const o=`emergency_harvester_${Game.time}`;if(e.spawnCreep([WORK,CARRY,MOVE],o,{memory:{role:"harvester"}})===OK)return void console.log(`🆘 Emergency harvester spawned: ${o}`)}for(const o of Object.keys(r)){const t=r[o];if(Object.values(Game.creeps).filter((e=>e.memory.role===o)).length<t){const r=e.room.energyAvailable,t=n(o,r),l={harvester:"h",builder:"b",upgrader:"u"},i=s(t),a=`${l[o]||o}_${i}_${Game.time}`;let m;if("harvester"===o){const r=c(e.room);if(!r){console.log("❌ No available source for harvester");continue}m=e.spawnCreep(t,a,{memory:{role:o,sourceId:r}}),m===OK&&console.log(`Spawning harvester: ${a} → source ${r}`)}else m=e.spawnCreep(t,a,{memory:{role:o}}),m===OK&&console.log(`Spawning ${o}: ${a}`);if(m===OK)break}}}(r);for(const e of Object.values(Game.rooms))i(e);for(const o in Game.creeps){const r=Game.creeps[o],t=r.memory.role;null===(e=u[t])||void 0===e||e.run(r)}};
