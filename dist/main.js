"use strict";var e;function r(e){var r;const o=e.controller,t=null!==(r=null==o?void 0:o.level)&&void 0!==r?r:0;if(t<2)return 1;const n=e.find(FIND_SOURCES).length,i=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,a=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length;if(2===t){return i<(CONTROLLER_STRUCTURES.extension[2]||5)||n>0&&a<n?2:2.5}return 3===t?3:t>3?3.5:t}function o(e){const r={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const o of Object.values(Game.creeps)){if(o.room.name!==e.name)continue;const t=o.memory.role;void 0!==r[t]&&r[t]++}return r}function t(e){return e.memory.resourceStats&&e.memory.resourceStats.tickLastUpdated===Game.time||function(e){e.memory.resourceStats||(e.memory.resourceStats={energyInStructures:0,energyInPiles:0,energyInTransit:0,totalEnergy:0,energyAvailable:0,energyCapacityAvailable:0,tickLastUpdated:0});const r=e.memory.resourceStats,o=e.find(FIND_STRUCTURES).reduce(((e,r)=>"store"in r&&r.store.getUsedCapacity(RESOURCE_ENERGY)>0?e+r.store.getUsedCapacity(RESOURCE_ENERGY):e),0),t=e.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY}).reduce(((e,r)=>e+r.amount),0),n=e.find(FIND_MY_CREEPS).reduce(((e,r)=>{var o;return e+((null===(o=r.store)||void 0===o?void 0:o.getUsedCapacity(RESOURCE_ENERGY))||0)}),0),i=o+t+n;r.energyInStructures=o,r.energyInPiles=t,r.energyInTransit=n,r.totalEnergy=i,r.energyAvailable=e.energyAvailable,r.energyCapacityAvailable=e.energyCapacityAvailable,r.tickLastUpdated=Game.time}(e),e.memory.resourceStats}function n(e){const r=t(e);console.log(`📊 [${e.name}] Energy Stats:\n    ➡️  Available: ${r.energyAvailable} / ${r.energyCapacityAvailable}\n    🏦 In Structures: ${r.energyInStructures}\n    🪙 On Ground:     ${r.energyInPiles}\n    🚚 In Transit:    ${r.energyInTransit}\n    🔄 Total Energy:  ${r.totalEnergy}\n    (Updated tick: ${r.tickLastUpdated})\n    `)}Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e.Harvester="harvester",e.Upgrader="upgrader",e.Builder="builder",e.Miner="miner",e.Hauler="hauler"}(e||(e={}));const i=Object.values(e);function a(o){const t=o.find(FIND_SOURCES);return 0===t.length||t.every((t=>{const n=e=>Object.values(Game.creeps).filter((r=>r.room.name===o.name&&r.memory.role===e&&r.memory.sourceId===t.id)).length;if(n(e.Miner)>=1)return!0;const i=r(o)<2.5?2:0;return i>0&&n(e.Harvester)>=i}))}function s(n){const s=r(n),l=o(n),c=n.find(FIND_CONSTRUCTION_SITES).length,m=n.find(FIND_SOURCES),R=m.length,u=i.reduce(((e,r)=>(e[r]=0,e)),{}),E=t(n),y=(l[e.Miner]||0)>0,d=(l[e.Harvester]||0)>0,f=n.energyAvailable<550;if(R>0&&!y&&!d&&f)return console.log(`[${n.name}] EMERGENCY: No income generation and critically low energy (${n.energyAvailable}). Demanding 1 Harvester.`),Object.assign(Object.assign({},u),{[e.Harvester]:1});let T;const g=2*R;switch(s){case 1:T=Object.assign(Object.assign({},u),{[e.Harvester]:g,[e.Upgrader]:a(n)?1:0});break;case 2:let r=0;if(n.memory.containerPositions)for(const e of m)if(n.memory.containerPositions[e.id]){const o=n.memory.containerPositions[e.id];n.lookForAt(LOOK_STRUCTURES,o.x,o.y).some((e=>e.structureType===STRUCTURE_CONTAINER))&&r++}const o=R-r;T=Object.assign(Object.assign({},u),{[e.Miner]:r,[e.Hauler]:r>0?Math.max(1,r)+(E.energyInPiles>750?1:0):0,[e.Harvester]:2*o,[e.Builder]:a(n)&&c>0?Math.min(2,c):0,[e.Upgrader]:a(n)&&0===c&&(r>0||n.energyAvailable>.5*n.energyCapacityAvailable)?1:0});break;case 2.5:T=Object.assign(Object.assign({},u),{[e.Miner]:R,[e.Hauler]:R+(E.energyInPiles>1e3?1:0),[e.Builder]:a(n)&&c>0?Math.min(2,c):0,[e.Upgrader]:a(n)&&0===c?Math.min(3,Math.floor(1.5*n.controller.level)):0});break;default:T=Object.assign(Object.assign({},u),{[e.Miner]:R,[e.Hauler]:R+(E.energyInPiles>1e3?1:0),[e.Builder]:a(n)&&c>0?Math.min(3,Math.ceil(c/5)):0,[e.Upgrader]:a(n)&&0===c?Math.min(6,Math.max(1,8-n.controller.level)):0})}E.energyInPiles>1e3&&T[e.Hauler]<R+1&&(T[e.Hauler]=(T[e.Hauler]||0)+1,T[e.Hauler]=Math.min(T[e.Hauler],R+2)),n.energyAvailable<.3*n.energyCapacityAvailable&&(l[e.Builder]||0)>0&&c>0&&T[e.Builder]>0&&(T[e.Builder]=Math.max(0,(T[e.Builder]||1)-1));const S=n.memory.roleDemandOverrides||{};for(const e of i)void 0!==S[e]&&null!==S[e]&&(T[e]=S[e]);return Game.time%10==0&&console.log("Demand",JSON.stringify(T)),T}function l(e,r,o){e.memory.roleDemandOverrides||(e.memory.roleDemandOverrides={}),null===o||o<0?void 0!==e.memory.roleDemandOverrides[r]?(delete e.memory.roleDemandOverrides[r],console.log(`[${e.name}] 🗑️ Cleared role demand override for: ${r}`),0===Object.keys(e.memory.roleDemandOverrides).length&&delete e.memory.roleDemandOverrides):console.log(`[${e.name}] Info: No override found for role ${r} to clear.`):(e.memory.roleDemandOverrides[r]=o,console.log(`[${e.name}] 🔧 Set role demand override: ${r} -> ${o}`))}"undefined"!=typeof Game&&(Game.setRoleDemandOverride=l,Game.clearRoleDemandOverride=function(e,r){l(e,r,null)},Game.clearAllDemandOverrides=function(e){e.memory.roleDemandOverrides?(delete e.memory.roleDemandOverrides,console.log(`[${e.name}] 🗑️ Cleared all role demand overrides.`)):console.log(`[${e.name}] Info: No overrides found to clear.`)});const c={harvester:{ratio:{work:3,carry:1,move:1},minEnergyForRatio:400,fallbackBody:[WORK,WORK,CARRY,MOVE]},miner:{ratio:{work:5,move:1},minEnergyForRatio:550,dontRepeatBody:!0},builder:{ratio:{work:2,carry:2,move:2},minEnergyForRatio:400,fallbackBody:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{ratio:{work:3,carry:2,move:3},minEnergyForRatio:550,fallbackBody:[WORK,WORK,CARRY,MOVE]},hauler:{ratio:{carry:6,move:3},minEnergyForRatio:450,fallbackBody:[CARRY,CARRY,CARRY,CARRY,MOVE,MOVE]}};function m(e){return e&&0!==e.length?e.reduce(((e,r)=>e+BODYPART_COST[r]),0):0}function R(r,o){const t=c[r];if(!t){console.log(`ERROR: No RoleConfig found for role: ${r}.`);const e=[WORK,CARRY,MOVE];return o>=m(e)?e:[]}const n=[],i=[];for(const[e,o]of Object.entries(t.ratio))if(void 0!==BODYPART_COST[e]){i.push(e);for(let r=0;r<o;r++)n.push(e)}else console.log(`ERROR: Invalid body part '${e}' in ratio for role ${r}`);const a=m(n);let s=[];if(o<t.minEnergyForRatio||0===a)t.fallbackBody&&t.fallbackBody.length>0&&o>=m(t.fallbackBody)&&(s=[...t.fallbackBody]);else if(t.dontRepeatBody)o>=a&&n.length>0&&n.length<=50&&(s=[...n]);else if(n.length>0){const e=Math.floor(o/a),r=n.length>0?Math.floor(50/n.length):0,t=Math.min(e,r);if(t>0)for(let e=0;e<t;e++)s.push(...n);let l=o-m(s);if(s.length<50&&l>0){let e;do{e=!1;for(const r of i){const o=BODYPART_COST[r];if(l>=o&&s.length<50&&(s.push(r),l-=o,e=!0),s.length>=50)break}}while(e&&s.length<50&&l>=Math.min(...i.map((e=>BODYPART_COST[e]))))}}if(0===s.length&&t.fallbackBody&&t.fallbackBody.length>0&&o>=m(t.fallbackBody)&&(s=[...t.fallbackBody]),0===s.length){let t=[];r===e.Harvester?t=[WORK,CARRY,MOVE]:r===e.Miner&&(t=[WORK,WORK,MOVE]),t.length>0&&o>=m(t)&&(s=t)}if(s.length>0){const e={[TOUGH]:1,[WORK]:2,[ATTACK]:3,[RANGED_ATTACK]:4,[CARRY]:5,[MOVE]:6,[HEAL]:7,[CLAIM]:8};s.sort(((r,o)=>(e[r]||99)-(e[o]||99)))}return s}function u(e){if(!e||0===e.length)return"empty";const r={};for(const o of e)r[o]=(r[o]||0)+1;return[TOUGH,WORK,CARRY,MOVE,ATTACK,RANGED_ATTACK,HEAL,CLAIM].filter((e=>r[e]&&r[e]>0)).map((e=>`${r[e]}${e[0]}`)).join("")}function E(o){if(function(o){const t=o.find(FIND_SOURCES);return 0===t.length||t.every((t=>{if(Object.values(Game.creeps).filter((r=>r.room.name===o.name&&r.memory.role===e.Miner&&r.memory.sourceId===t.id)).length>=1)return!0;const n=r(o);if(n<2.5){if(Object.values(Game.creeps).filter((r=>r.room.name===o.name&&r.memory.role===e.Harvester&&r.memory.sourceId===t.id)).length>=(n<2?2:1))return!0}return!1}))}(o))return!0;return o.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(RESOURCE_ENERGY)>50}).length>0||o.energyAvailable>.8*o.energyCapacityAvailable}function y(e,r,o,t){const n=e.find(FIND_SOURCES),i={};for(const e of n)i[e.id]=0;for(const o in Game.creeps){const t=Game.creeps[o];t.room.name===e.name&&t.memory.role===r&&t.memory.sourceId&&void 0!==i[t.memory.sourceId]&&i[t.memory.sourceId]++}for(const e of t)e.memory.role===r&&e.memory.sourceId&&void 0!==i[e.memory.sourceId]&&i[e.memory.sourceId]++;const a=n.find((e=>(i[e.id]||0)<o));return(null==a?void 0:a.id)||null}function d(r,o){const t=r.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});if(0===t.length)return null;const n={};for(const e of t)n[e.id]=0;for(const o in Game.creeps){const t=Game.creeps[o];t.room.name===r.name&&t.memory.role===e.Hauler&&t.memory.containerId&&void 0!==n[t.memory.containerId]&&n[t.memory.containerId]++}for(const r of o)r.memory.role===e.Hauler&&r.memory.containerId&&void 0!==n[r.memory.containerId]&&n[r.memory.containerId]++;const i=t.find((e=>(n[e.id]||0)<1));return(null==i?void 0:i.id)||null}function f(t){var n;if(t.spawning){return void(Game.creeps[t.spawning.name]&&t.room.visual.text(`🛠️ ${t.spawning.name} (${t.spawning.remainingTime})`,t.pos.x+1,t.pos.y,{align:"left",opacity:.8,font:"0.7 Arial"}))}const i=t.room;Game.time%3==1&&i.find(FIND_MY_SPAWNS)[0].id===t.id&&function(t){t.memory.spawnQueue||(t.memory.spawnQueue=[]);const n=s(t),i=o(t),a=t.energyCapacityAvailable,l=[...t.memory.spawnQueue];let c=[];const f={[e.Harvester]:"hrv",[e.Builder]:"bld",[e.Upgrader]:"upg",[e.Miner]:"mnr",[e.Hauler]:"hal"},T=Object.values(e).reduce(((e,r)=>(e[r]=0,e)),{});for(const e of l){const r=e.role,o=i[r]||0,a=n[r]||0;o+T[r]+1<=a?(c.push(e),T[r]++):Game.time%25==1&&console.log(`[${t.name}] Pruning ${e.role} ${e.name} from spawn queue (demand met).`)}const g=[e.Miner,e.Hauler,e.Harvester,e.Builder,e.Upgrader];for(const o of g){const s=i[o]||0;let l=(n[o]||0)-s-(T[o]||0);if(l>0){o!==e.Builder&&o!==e.Upgrader||E(t)||(Game.time%20==4&&l>0&&console.log(`[${t.name}] 🚫 Postponing new ${o}(s) (${l}), economy not stable enough.`),l=0);for(let n=0;n<l;n++){if(c.length>=10){console.log(`[${t.name}] Spawn queue reached limit (10). Halting further additions this tick.`);break}const i=R(o,a);if(0===i.length){Game.time%20==5&&console.log(`[${t.name}] ⚠️ Cannot determine body for new ${o} (capacity ${a}).`);continue}const s=m(i),l=u(i);let E=0,g="";do{g=`${f[o]||o[0]}${l}_${Game.time%1e3+n+E}`,E++}while((Game.creeps[g]||c.some((e=>e.name===g)))&&E<10);if(Game.creeps[g]||c.some((e=>e.name===g))){console.log(`[${t.name}] Failed to generate unique name for ${o} after ${E} attempts. Skipping.`);continue}const S={role:o};if(o===e.Miner||o===e.Harvester){const n=y(t,o,o===e.Miner?1:r(t)<2.5?2:1,c);if(n)S.sourceId=n;else if(o===e.Miner){Game.time%5==2&&console.log(`[${t.name}] No source slot for new Miner request. Not queuing.`);continue}}else if(o===e.Hauler){const e=d(t,c);e&&(S.containerId=e)}const p={role:o,body:i,name:g,memory:S,timestamp:Game.time,cost:s};c.push(p),T[o]++}}if(c.length>=10)break}JSON.stringify(t.memory.spawnQueue)!==JSON.stringify(c)&&(t.memory.spawnQueue=c,Game.time%10==7&&console.log(`[${t.name}] ♻ Spawn Queue updated (${l.length} -> ${c.length}): ${c.map((e=>e.role[0])).join("")||"empty"}`))}(i);const a=i.memory.spawnQueue;if(!a||0===a.length)return;const l=a[0];if(i.energyAvailable<l.cost)return void(Game.time%15==2&&t.id===(null===(n=i.find(FIND_MY_SPAWNS)[0])||void 0===n?void 0:n.id)&&console.log(`[${i.name}/${t.name}] ⏳ Waiting for energy (${i.energyAvailable}/${l.cost}) for ${l.role} ${l.name}`));const c=t.spawnCreep(l.body,l.name,{memory:l.memory});c===OK?(console.log(`[${i.name}/${t.name}] ✅ Spawning ${l.role}: ${l.name} (cost: ${l.cost})`),a.shift()):c!==ERR_BUSY&&c!==ERR_NOT_ENOUGH_ENERGY&&(console.log(`[${i.name}/${t.name}] ❌ Failed to spawn ${l.name} (role ${l.role}) with error: ${c}. Body: ${JSON.stringify(l.body)}, Memory: ${JSON.stringify(l.memory)}`),c!==ERR_INVALID_ARGS&&c!==ERR_NAME_EXISTS||(console.log(`[${i.name}/${t.name}] Removing problematic spawn request: ${l.name}`),a.shift()))}const T=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function g(e){if(Game.time%10!=0)return;switch(r(e)){case 2:S(e),function(e){const r=e.find(FIND_MY_SPAWNS)[0];if(!r)return;e.memory.containerPositions||(e.memory.containerPositions={});for(const o of e.find(FIND_SOURCES)){const t=e.memory.containerPositions[o.id];if(t){const r=e.lookForAt(LOOK_STRUCTURES,t.x,t.y).some((e=>e.structureType===STRUCTURE_CONTAINER)),n=e.lookForAt(LOOK_CONSTRUCTION_SITES,t.x,t.y).some((e=>e.structureType===STRUCTURE_CONTAINER));if(r||n)continue;delete e.memory.containerPositions[o.id],console.log(`⚠️ Container for source ${o.id} missing, memory cleared`)}console.log("no memory of this source having a container",o);const n=p.map((([r,t])=>new RoomPosition(o.pos.x+r,o.pos.y+t,e.name))).filter((r=>e.getTerrain().get(r.x,r.y)!==TERRAIN_MASK_WALL&&(!(r.lookFor(LOOK_STRUCTURES).length>0)&&!(r.lookFor(LOOK_CONSTRUCTION_SITES).length>0))));if(0===n.length)continue;n.sort(((e,o)=>r.pos.getRangeTo(e)-r.pos.getRangeTo(o)));const i=n[0],a=e.createConstructionSite(i.x,i.y,STRUCTURE_CONTAINER);a===OK?(e.memory.containerPositions[o.id]={x:i.x,y:i.y},console.log(`✏️ Placed container for source ${o.id} at (${i.x},${i.y})`)):console.log(`❌ Failed to place container at (${i.x},${i.y}): ${a}`)}}(e);break;case 2.5:!function(e){var r;const o=e.find(FIND_MY_SPAWNS)[0],t=e.controller;if(!o||!t)return;if(!e.memory.roadSitesPlanned){const a=[];function s(e){for(const r of e)r.x,r.y,a.find((e=>e.x===r.x&&e.y===r.y))||a.push({x:r.x,y:r.y})}const l=e.find(FIND_SOURCES);for(const c of l){const m=null===(r=e.memory.containerPositions)||void 0===r?void 0:r[c.id];if(!m)continue;const R=new RoomPosition(m.x,m.y,e.name);s(PathFinder.search(R,{pos:o.pos,range:1},{plainCost:2,swampCost:10,roomCallback:e=>{const r=Game.rooms[e];if(!r)return!1;const o=new PathFinder.CostMatrix;return r.find(FIND_STRUCTURES).forEach((e=>{e.structureType===STRUCTURE_ROAD&&o.set(e.pos.x,e.pos.y,1)})),o}}).path)}s(PathFinder.search(o.pos,{pos:t.pos,range:3},{plainCost:2,swampCost:10}).path),e.memory.roadSitesPlanned=a}const n=e.memory.roadSitesPlanned;let i=0;for(const{x:u,y:E}of n){if(i>=5)break;const y=new RoomPosition(u,E,e.name);y.lookFor(LOOK_STRUCTURES).some((e=>e.structureType===STRUCTURE_ROAD))||y.lookFor(LOOK_CONSTRUCTION_SITES).some((e=>e.structureType===STRUCTURE_ROAD))||e.createConstructionSite(u,E,STRUCTURE_ROAD)===OK&&i++}}(e);break;case 3:S(e)}}function S(e){const r=e.controller;if(!r||!r.my||r.level<2)return;const o=CONTROLLER_STRUCTURES.extension[r.level]-(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length+e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length);if(o<=0)return;const t=e.find(FIND_MY_SPAWNS)[0];if(!t)return;let n=0;for(const[r,i]of T){if(n>=o)return;const a=t.pos.x+r,s=t.pos.y+i;if(!(e.lookForAt(LOOK_STRUCTURES,a,s).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,a,s).length>0)){e.createConstructionSite(a,s,STRUCTURE_EXTENSION)===OK&&n++}}}const p=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];class O{collectEnergy(r){const o=r.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>Math.min(50,r.store.getFreeCapacity(RESOURCE_ENERGY)/2)});if(o)return void(r.pickup(o)===ERR_NOT_IN_RANGE&&r.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"},range:1}));const t=r.room.find(FIND_STRUCTURES,{filter:o=>(o.structureType===STRUCTURE_CONTAINER||o.structureType===STRUCTURE_STORAGE)&&o.store.getUsedCapacity(RESOURCE_ENERGY)>(r.memory.role===e.Upgrader?100:50)});if(t.length>0){t.sort(((e,o)=>{const t=e.store.getUsedCapacity(RESOURCE_ENERGY)||0,n=o.store.getUsedCapacity(RESOURCE_ENERGY)||0;return n!==t?n-t:r.pos.getRangeTo(e)-r.pos.getRangeTo(o)}));const e=t[0];return void(e&&r.withdraw(e,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&r.moveTo(e,{visualizePathStyle:{stroke:"#00ff00"},range:1}))}const n=r.room.memory.spawnQueue,i=!n||0===n.length;if(i){const e=r.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(e.length>0){const o=r.pos.findClosestByPath(e);return void(o&&r.withdraw(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&r.moveTo(o,{visualizePathStyle:{stroke:"#ffff00"},range:1}))}}else r.memory.role===e.Upgrader&&Game.time%5==0&&r.say("⏳Spawn busy");const a=r.room.find(FIND_SOURCES_ACTIVE);if(a.length>0){if(r.memory.role===e.Upgrader&&(t.length>0||!i)&&r.room.energyAvailable>0)return void(Game.time%7==0&&r.say("🤔 Waiting"));const o=r.pos.findClosestByPath(a);o&&r.harvest(o)===ERR_NOT_IN_RANGE&&r.moveTo(o,{visualizePathStyle:{stroke:"#ff0000"},range:1})}else Game.time%10==0&&r.say("🚫 No Energy")}updateWorkingState(e){e.memory.atCapacity&&0===e.store.getUsedCapacity(RESOURCE_ENERGY)&&(e.memory.atCapacity=!1),e.memory.atCapacity||0!==e.store.getFreeCapacity(RESOURCE_ENERGY)||(e.memory.atCapacity=!0)}deliverEnergy(r){const o=r.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION||e.structureType===STRUCTURE_TOWER)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(o.length>0){o.sort(((e,o)=>e.structureType===STRUCTURE_TOWER&&o.structureType!==STRUCTURE_TOWER?-1:o.structureType===STRUCTURE_TOWER&&e.structureType!==STRUCTURE_TOWER?1:e.structureType===STRUCTURE_TOWER&&o.structureType===STRUCTURE_TOWER?(e.store.getUsedCapacity(RESOURCE_ENERGY)||0)-(o.store.getUsedCapacity(RESOURCE_ENERGY)||0):r.pos.getRangeTo(e)-r.pos.getRangeTo(o)));const e=o[0];e&&r.transfer(e,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&r.moveTo(e,{visualizePathStyle:{stroke:"#ffffff"},range:1})}else r.memory.role!==e.Upgrader&&r.say("🤷‍♂️ full?")}}function C(e){if(e.store.getFreeCapacity(RESOURCE_ENERGY)>0){const r=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(r)return void(e.pickup(r)===ERR_NOT_IN_RANGE&&e.moveTo(r))}const r=e.room.find(FIND_CONSTRUCTION_SITES);if(r.length>0){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY)){const o=e.pos.findClosestByPath(r);return void(o&&e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o))}{const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0});if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}}const t=e.room.controller;if(t&&function(e){const r=s(e),t=o(e);for(const e of i)if(t[e]<(r[e]||0))return!1;return!0}(e.room)){const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0}),o=200;if(r.reduce(((e,r)=>e+r.store[RESOURCE_ENERGY]),0)>=o||e.room.energyAvailable>=o){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY))return void(e.upgradeController(t)===ERR_NOT_IN_RANGE&&e.moveTo(t));if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}}e.say("🪑 idle")}const _={[STRUCTURE_CONTAINER]:{pct:.8},[STRUCTURE_ROAD]:{pct:.5},[STRUCTURE_EXTENSION]:{pct:.8}};const N={harvester:new class extends O{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performDelivery(e):this.performHarvest(e)}performHarvest(e){let r=null;if(e.memory.sourceId&&(r=Game.getObjectById(e.memory.sourceId),r||(delete e.memory.sourceId,r=null)),!r){const o=e.room.find(FIND_SOURCES_ACTIVE);o.length>0&&(r=e.pos.findClosestByPath(o),r&&(e.memory.sourceId=r.id,e.say("🔄 New Src")))}if(r){const o=e.harvest(r);o===ERR_NOT_IN_RANGE?e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}}):o===OK||(o===ERR_NOT_ENOUGH_RESOURCES?(delete e.memory.sourceId,e.say("⛏️ Empty")):o===ERR_NO_BODYPART&&e.say("💔 No WORK"))}else e.say("❓ No Src"),C(e)}performDelivery(e){if(super.deliverEnergy(e),e.store.getUsedCapacity(RESOURCE_ENERGY)>0){e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0}).length>0||(e.say("🚚 IdleFull"),C(e))}}},builder:new class extends O{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performWork(e):super.collectEnergy(e)}performWork(e){this.tryPriorityRepair(e)||this.tryBuild(e)||this.tryGeneralRepair(e)||(e.say("👷 Idle"),C(e))}tryPriorityRepair(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)return!1;const r=_[e.structureType];return!!r&&(null!=r.pct&&e.hits<e.hitsMax*r.pct||null!=r.hp&&e.hits<r.hp)}});if(r.length>0){const o=e.pos.findClosestByPath(r);if(o)return e.say("🛠️ Prior"),e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ff0000"}}),!0}return!1}tryBuild(e){const r=e.room.find(FIND_CONSTRUCTION_SITES);if(r.length>0){const o=e.pos.findClosestByPath(r);if(o)return e.say("🚧 Build"),e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}}),!0}return!1}tryGeneralRepair(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_WALL&&e.structureType!==STRUCTURE_RAMPART&&e.hits<e.hitsMax});if(r.length>0){const o=e.pos.findClosestByPath(r);if(o)return e.say("🔧 Repair"),e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}}),!0}return!1}},upgrader:new class extends O{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performUpgrade(e):super.collectEnergy(e)}performUpgrade(e){const r=e.room.controller;if(r&&r.my){const o=e.upgradeController(r);o===ERR_NOT_IN_RANGE?e.moveTo(r,{visualizePathStyle:{stroke:"#4CAF50"},range:3}):o===OK||(o===ERR_NOT_ENOUGH_RESOURCES?(e.memory.atCapacity=!1,e.say("⛏️ Empty!")):e.say(`⚠️ UpgErr ${o}`))}else e.say("❓ No Ctrlr"),C(e)}},miner:new class extends O{run(e){if(!this.hasValidAssignments(e))return;const{x:r,y:o}=e.room.memory.containerPositions[e.memory.sourceId],t=new RoomPosition(r,o,e.room.name);e.pos.isEqualTo(t)?this.performHarvesting(e):this.moveToDesignatedPosition(e,t)}hasValidAssignments(e){const r=e.memory.sourceId;if(!r)return e.say("❓NoSrcID"),console.log(`Miner ${e.name} is missing sourceId.`),!1;const o=e.room.memory.containerPositions;return!(!o||!o[r])||(e.say("❌NoSpot"),console.log(`Miner ${e.name} (source: ${r}) is missing a designated containerPosition in room memory.`),!1)}moveToDesignatedPosition(e,r){e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"},range:0})}performHarvesting(e){const r=Game.getObjectById(e.memory.sourceId);if(!r)return e.say("❓SrcGone"),console.log(`Miner ${e.name} assigned source ${e.memory.sourceId} no longer exists or is not visible.`),void delete e.memory.sourceId;const o=e.harvest(r);o===OK||(o===ERR_NOT_ENOUGH_RESOURCES?e.say("⛏️Empty"):o===ERR_BUSY||(o===ERR_NO_BODYPART?(e.say("💔NoWORK"),console.log(`Miner ${e.name} has no WORK parts.`)):o===ERR_NOT_OWNER?e.say("🏢NotMyCtrlr"):o===ERR_INVALID_TARGET?(e.say("❌InvTrg"),console.log(`Miner ${e.name} has invalid harvest target: ${r}`),delete e.memory.sourceId):(e.say(`💀HrvFail:${o}`),console.log(`Miner ${e.name} failed to harvest source ${r.id} with error: ${o}`))))}},hauler:new class extends O{run(e){if(this.updateWorkingState(e),e.memory.atCapacity){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(r.length>0)return void(e.transfer(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}const r=e.memory.containerId,o=r?Game.getObjectById(r):null;o&&o.store.getUsedCapacity(RESOURCE_ENERGY)>0?e.withdraw(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o):C(e)}}},U=function(e,r){const o=Game.cpu.getUsed(),t=r(),n=Game.cpu.getUsed()-o;return console.log(`📊 ${e}: ${n.toFixed(2)} CPU`),t}("main loop",(function(){!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`🧹 Cleaned up memory for dead creep: ${e}`))}();const e=Object.values(Game.spawns)[0];e&&f(e);for(const e in Game.rooms){const r=Game.rooms[e];g(r),Game.time%10==0&&n(r)}for(const e in Game.creeps){const r=Game.creeps[e];if(!r.spawning){const e=r.memory.role;e&&N[e]?N[e].run(r):console.log(`Creep ${r.name} has an unknown or undefined role: ${e}`)}}}));exports.loop=U;
