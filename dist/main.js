"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e={harvester:2,upgrader:1,builder:1},r={harvester:[WORK,CARRY,MOVE,MOVE],upgrader:[WORK,CARRY,MOVE,MOVE],builder:[WORK,CARRY,MOVE,MOVE]};const o=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function t(e){const r=e.controller;if(!r||!r.my||r.level<2)return;const t=CONTROLLER_STRUCTURES.extension[r.level]-(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length+e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length);if(t<=0)return;const n=e.find(FIND_MY_SPAWNS)[0];if(!n)return;let s=0;for(const[r,R]of o){if(s>=t)return;const o=n.pos.x+r,i=n.pos.y+R;if(!(e.lookForAt(LOOK_STRUCTURES,o,i).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,o,i).length>0)){e.createConstructionSite(o,i,STRUCTURE_EXTENSION)===OK&&s++}}}class n{collectEnergy(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]));const o=e.room.find(FIND_SOURCES);o.length>0&&e.harvest(o[0])===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}updateWorkingState(e){e.memory.working&&0===e.store[RESOURCE_ENERGY]&&(e.memory.working=!1),e.memory.working||0!==e.store.getFreeCapacity()||(e.memory.working=!0)}}const s={upgrader:new class extends n{run(e){this.updateWorkingState(e),e.memory.working?e.upgradeController(e.room.controller)===ERR_NOT_IN_RANGE&&e.moveTo(e.room.controller):this.collectEnergy(e)}},builder:new class extends n{run(e){this.updateWorkingState(e),e.memory.working?this.build(e):this.collectEnergy(e)}build(e){const r=e.room.find(FIND_CONSTRUCTION_SITES);if(0===r.length){const r=e.room.find(FIND_MY_SPAWNS)[0];return void(r&&e.moveTo(r))}const o=e.pos.findClosestByRange(r);o&&e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o)}},harvester:new class extends n{run(e){this.updateWorkingState(e),e.memory.working?this.deliverEnergy(e):this.harvest(e)}deliverEnergy(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});r.length>0&&e.transfer(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0])}harvest(e){const r=e.room.find(FIND_SOURCES);r.length>0&&e.harvest(r[0])===ERR_NOT_IN_RANGE&&e.moveTo(r[0])}}};exports.loop=function(){var o;!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`ðŸ§¹ Cleaned up memory for dead creep: ${e}`))}();const n=Object.values(Game.spawns)[0];n&&function(o){if(0===Object.values(Game.creeps).filter((e=>"harvester"===e.memory.role)).length&&o.store[RESOURCE_ENERGY]>=200){const e=`harvester_${Game.time}`;if(o.spawnCreep([WORK,CARRY,MOVE],e,{memory:{role:"harvester"}})===OK)return void console.log(`ðŸ†˜ Emergency harvester spawned: ${e}`)}for(const t in e){const n=t;if(Object.values(Game.creeps).filter((e=>e.memory.role===n)).length<e[n]){const e=`${n}_${Game.time}`;if(o.spawnCreep(r[n],e,{memory:{role:n}})===OK){console.log(`Spawning ${n}: ${e}`);break}}}}(n);for(const e of Object.values(Game.rooms))t(e);for(const e in Game.creeps){const r=Game.creeps[e],t=r.memory.role;null===(o=s[t])||void 0===o||o.run(r)}};
