"use strict";var e;function r(e){var r,o;if((null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0)<2)return 1;const t=e.find(FIND_SOURCES).length,n=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,s=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length;return n<5||s<t?2:2.5}Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e.Harvester="harvester",e.Upgrader="upgrader",e.Builder="builder",e.Miner="miner",e.Hauler="hauler"}(e||(e={}));const o=Object.values(e);function t(r){return r.find(FIND_SOURCES).every((o=>{const t=e=>e.room.name===r.name,n=e=>e.memory.sourceId===o.id;if(Object.values(Game.creeps).filter((r=>t(r)&&r.memory.role===e.Miner&&n(r))).length>=1)return!0;return Object.values(Game.creeps).filter((r=>t(r)&&r.memory.role===e.Harvester&&n(r))).length>=2}))}function n(n){const s=r(n),i=n.find(FIND_CONSTRUCTION_SITES).length,c=n.find(FIND_SOURCES),l=2*c.length;Object.values(Game.creeps).filter((r=>r.memory.role===e.Harvester&&r.room.name===n.name)).length;const a=o.reduce(((e,r)=>(e[r]=0,e)),{});switch(s){case 1:return Object.assign(Object.assign({},a),{harvester:l,upgrader:t(n)?1:0});case 2:const e=n.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});return Object.assign(Object.assign({},a),{harvester:e.length>=1?l/2:l,builder:t(n)&&i>0?1:0,hauler:e.length>=1?1:0,miner:e.length>=1?1:0});case 2.5:return Object.assign(Object.assign({},a),{miner:c.length,hauler:c.length,builder:i>0?1:0,upgrader:1});default:return Object.assign(Object.assign({},a),{harvester:l,builder:i>0?1:0,upgrader:i>0?0:1})}}const s={harvester:{work:3,carry:1,move:1},builder:{work:1,carry:2,move:2},upgrader:{work:2,carry:2,move:1},miner:{work:5,move:1},hauler:{carry:6,move:3}};const i=[WORK,CARRY,CARRY,MOVE,MOVE];function c(e,r){const o=s[e];if(!o)return i;const t=function(e,r,o={work:100,carry:50,move:50}){const t=[],n=[];for(const r in e){const o=e[r];for(let e=0;e<o;e++)n.push(r)}const s=n.reduce(((e,r)=>e+o[r]),0),i=Math.floor(r/s),c=Math.min(i*n.length,50);for(let e=0;e<c;e++)t.push(n[e%n.length]);return t}(o,r);return t.length>0?t:i}function l(e){const r={work:0,carry:0,move:0,attack:0,ranged_attack:0,tough:0,heal:0,claim:0};for(const o of e)r[o]++;return Object.entries(r).filter((([e,r])=>r>0)).map((([e,r])=>`${r}${e[0]}`)).join("")}function a(e,r,o=2){const t=e.find(FIND_SOURCES),n={};for(const e of t)n[e.id]=0;for(const e of Object.values(Game.creeps))e.memory.role===r&&e.memory.sourceId&&(n[e.memory.sourceId]=(n[e.memory.sourceId]||0)+1);const s=t.find((e=>n[e.id]<o));return(null==s?void 0:s.id)||null}function m(e){const r=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}),o={};for(const e of r)o[e.id]=0;for(const e of Object.values(Game.creeps))"hauler"===e.memory.role&&e.memory.containerId&&(o[e.memory.containerId]=(o[e.memory.containerId]||0)+1);const t=r.find((e=>o[e.id]<1));return(null==t?void 0:t.id)||null}const u=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function R(e){if(Game.time%10!=0)return;if(2===r(e))!function(e){const r=e.controller;if(!r||!r.my||r.level<2)return;const o=CONTROLLER_STRUCTURES.extension[r.level],t=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,n=e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,s=o-(t+n);if(s<=0)return;const i=e.find(FIND_MY_SPAWNS)[0];if(!i)return;let c=0;for(const[r,o]of u){if(c>=s)return;const t=i.pos.x+r,n=i.pos.y+o;if(!(e.lookForAt(LOOK_STRUCTURES,t,n).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,t,n).length>0)){e.createConstructionSite(t,n,STRUCTURE_EXTENSION)===OK&&c++}}}(e),function(e){const r=e.find(FIND_MY_SPAWNS)[0];if(!r)return;e.memory.containerPositions||(e.memory.containerPositions={});for(const o of e.find(FIND_SOURCES)){if(e.memory.containerPositions[o.id])continue;const t=f.map((([r,t])=>new RoomPosition(o.pos.x+r,o.pos.y+t,e.name))).filter((r=>e.getTerrain().get(r.x,r.y)!==TERRAIN_MASK_WALL&&(!(r.lookFor(LOOK_STRUCTURES).length>0)&&!(r.lookFor(LOOK_CONSTRUCTION_SITES).length>0))));if(0===t.length)continue;t.sort(((e,o)=>r.pos.getRangeTo(e)-r.pos.getRangeTo(o)));const n=t[0],s=e.createConstructionSite(n.x,n.y,STRUCTURE_CONTAINER);s===OK?(e.memory.containerPositions[o.id]={x:n.x,y:n.y},console.log(`‚úèÔ∏è Placed container for source ${o.id} at (${n.x},${n.y})`)):console.log(`‚ùå Failed to place container at (${n.x},${n.y}): ${s}`)}}(e)}const f=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];class E{collectEnergy(e){if(Object.values(Game.creeps).some((e=>"harvester"===e.memory.role))){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}const r=e.room.find(FIND_SOURCES);r.length>0&&e.harvest(r[0])===ERR_NOT_IN_RANGE&&e.moveTo(r[0])}updateWorkingState(e){e.memory.working&&0===e.store[RESOURCE_ENERGY]&&(e.memory.working=!1),e.memory.working||0!==e.store.getFreeCapacity()||(e.memory.working=!0)}}function T(e,r){const o=c(r,e.room.energyCapacityAvailable),t=e.body.map((e=>e.type)),n=new Set(o);for(const e of n)if(!t.includes(e))return!1;return!0}function d(e){const r=e.room.find(FIND_CONSTRUCTION_SITES);if(r.length>0){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY)){const o=e.pos.findClosestByPath(r);return void(o&&e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o))}{const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0});if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}}const o=e.room.controller;if(o&&function(e){const r=n(e),o={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const r of Object.values(Game.creeps))r.room.name===e.name&&(o[r.memory.role]=(o[r.memory.role]||0)+1);for(const e of Object.keys(r))if(o[e]<r[e])return!1;return!0}(e.room)){const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0}),t=200;if(r.reduce(((e,r)=>e+r.store[RESOURCE_ENERGY]),0)>=t||e.room.energyAvailable>=t){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY))return void(e.upgradeController(o)===ERR_NOT_IN_RANGE&&e.moveTo(o));if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}}e.say("ü™ë idle")}const N={harvester:new class extends E{run(e){this.updateWorkingState(e),e.memory.working?this.deliverEnergy(e):this.harvest(e)}deliverEnergy(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});r.length>0&&e.transfer(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0])}harvest(e){const r=e.memory.sourceId;let o=r?Game.getObjectById(r):null;if(!o){if(o=e.pos.findClosestByPath(FIND_SOURCES),!o)return void e.say("‚ùì no src");e.memory.sourceId=o.id,e.say("üîÅ")}e.harvest(o)===ERR_NOT_IN_RANGE&&e.moveTo(o)}},builder:new class extends E{run(e){this.updateWorkingState(e),e.memory.working?this.buildOrRepair(e):this.collectEnergy(e)}buildOrRepair(e){const r={[STRUCTURE_CONTAINER]:{pct:.8},[STRUCTURE_ROAD]:{hp:5e3},[STRUCTURE_EXTENSION]:{pct:.8}},o=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)return!1;const o=r[e.structureType];if(!o)return!1;const t=e.hitsMax-e.hits;return null!=o.pct&&e.hits<e.hitsMax*o.pct||null!=o.hp&&t>o.hp}});if(o.length>0){const r=e.pos.findClosestByRange(o);return void(r&&e.repair(r)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ff0000"}}))}const t=e.room.find(FIND_CONSTRUCTION_SITES);if(0===t.length){const r=e.room.find(FIND_MY_SPAWNS)[0];return void(r&&e.moveTo(r))}const n=e.pos.findClosestByRange(t);n&&e.build(n)===ERR_NOT_IN_RANGE&&e.moveTo(n,{visualizePathStyle:{stroke:"#ffffff"}})}},upgrader:new class extends E{run(e){this.updateWorkingState(e),e.memory.working?e.upgradeController(e.room.controller)===ERR_NOT_IN_RANGE&&e.moveTo(e.room.controller):this.collectEnergy(e)}},miner:new class extends E{run(e){const r=e.memory.sourceId,o=e.room.memory.containerPositions;if(!r)return void e.say("‚ùì no src");if(!o||!o[r])return void e.say("‚ùå no pos");const{x:t,y:n}=o[r],s=new RoomPosition(t,n,e.room.name);if(!e.pos.isEqualTo(s))return void e.moveTo(s,{visualizePathStyle:{stroke:"#ffaa00"}});const i=Game.getObjectById(r);if(!i)return void e.say("‚ùì src gone");e.harvest(i)!==OK&&e.say("üíÄ fail")}},hauler:new class extends E{run(e){if(this.updateWorkingState(e),e.memory.working){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(r.length>0)return void(e.transfer(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}const r=e.memory.containerId?Game.getObjectById(e.memory.containerId):null;r&&r.store[RESOURCE_ENERGY]>0?e.withdraw(r,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r):d(e)}}};exports.loop=function(){var r;!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`üßπ Cleaned up memory for dead creep: ${e}`))}(),function(){if(Game.time%10==0)for(const e of Object.values(Game.rooms)){const r=n(e);for(const e of Object.keys(r)){const o=r[e],t=Object.values(Game.creeps).filter((r=>r.memory.role!==e&&(!r.memory.lockUntil||Game.time>=r.memory.lockUntil)&&T(r,e))),n={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const e of Object.values(Game.creeps))n[e.memory.role]=(n[e.memory.role]||0)+1;if(n[e]>=o)continue;const s=t.find((e=>{var o;const t=n[e.memory.role],s=null!==(o=r[e.memory.role])&&void 0!==o?o:0;return 0===s||t>s}));if(s){console.log(`üîÅ ${s.name}: ${s.memory.role} ‚Üí ${e}`),s.memory.role=e,s.memory.lockUntil=Game.time+100;break}console.log(`‚ö†Ô∏è No reassignable creeps found for role '${e}'`),console.log(`  Needed: ${o}, Current: ${n[e]}`),console.log("  Candidates:",t.map((e=>`${e.name} (${e.memory.role})`)))}}}();const o=Object.values(Game.spawns)[0];o&&function(r){const o=n(r.room);Game.time%10==0&&console.log(o);for(const t of Object.keys(o)){const n=o[t];if(Object.values(Game.creeps).filter((e=>e.memory.role===t)).length<n){const o=r.room.energyAvailable,n=c(t,o),s={harvester:"hr",builder:"b",upgrader:"u",miner:"m",hauler:"hl"},i=l(n),u=`${s[t]||t}_${i}_${Game.time}`;let R;if(t===e.Harvester||t===e.Miner){const o=t===e.Miner?1:2,s=a(r.room,t,o);if(!s){console.log("‚ùå No available source for role"+t);continue}R=r.spawnCreep(n,u,{memory:{role:t,sourceId:s}}),R===OK&&console.log(`Spawning harvester: ${u} ‚Üí source ${s}`)}else if(t===e.Hauler){const e=m(r.room);if(!e){console.log("‚ùå No available container for hauler");continue}R=r.spawnCreep(n,u,{memory:{role:t,containerId:e}}),R===OK&&console.log(`Spawning hauler: ${u} ‚Üí container ${e}`)}else R=r.spawnCreep(n,u,{memory:{role:t}}),R===OK&&console.log(`Spawning ${t}: ${u}`);if(R===OK)break}}}(o);for(const e of Object.values(Game.rooms))R(e);for(const e in Game.creeps){const o=Game.creeps[e],t=o.memory.role;null===(r=N[t])||void 0===r||r.run(o)}};
