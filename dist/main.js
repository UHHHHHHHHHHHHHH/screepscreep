"use strict";function e(e){const o=e.find(FIND_CONSTRUCTION_SITES).length;return{harvester:2,builder:o>0?1:0,upgrader:o>0?0:1}}Object.defineProperty(exports,"__esModule",{value:!0});const o={harvester:[WORK,WORK,CARRY,MOVE],upgrader:[WORK,CARRY,MOVE,MOVE],builder:[WORK,CARRY,MOVE,MOVE]};const r=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function t(e){const o=e.controller;if(!o||!o.my||o.level<2)return;const t=CONTROLLER_STRUCTURES.extension[o.level]-(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length+e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length);if(t<=0)return;const n=e.find(FIND_MY_SPAWNS)[0];if(!n)return;let s=0;for(const[o,c]of r){if(s>=t)return;const r=n.pos.x+o,i=n.pos.y+c;if(!(e.lookForAt(LOOK_STRUCTURES,r,i).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,r,i).length>0)){e.createConstructionSite(r,i,STRUCTURE_EXTENSION)===OK&&s++}}}class n{collectEnergy(e){if(Object.values(Game.creeps).some((e=>"harvester"===e.memory.role))){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}const o=e.room.find(FIND_SOURCES);o.length>0&&e.harvest(o[0])===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}updateWorkingState(e){e.memory.working&&0===e.store[RESOURCE_ENERGY]&&(e.memory.working=!1),e.memory.working||0!==e.store.getFreeCapacity()||(e.memory.working=!0)}}function s(e,r){const t=o[r],n=e.body.map((e=>e.type)),s=new Set(t);for(const e of s)if(!n.includes(e))return!1;return!0}const c={upgrader:new class extends n{run(e){this.updateWorkingState(e),e.memory.working?e.upgradeController(e.room.controller)===ERR_NOT_IN_RANGE&&e.moveTo(e.room.controller):this.collectEnergy(e)}},builder:new class extends n{run(e){this.updateWorkingState(e),e.memory.working?this.build(e):this.collectEnergy(e)}build(e){const o=e.room.find(FIND_CONSTRUCTION_SITES);if(0===o.length){const o=e.room.find(FIND_MY_SPAWNS)[0];return void(o&&e.moveTo(o))}const r=e.pos.findClosestByRange(o);r&&e.build(r)===ERR_NOT_IN_RANGE&&e.moveTo(r)}},harvester:new class extends n{run(e){this.updateWorkingState(e),e.memory.working?this.deliverEnergy(e):this.harvest(e)}deliverEnergy(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});o.length>0&&e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}harvest(e){const o=e.room.find(FIND_SOURCES);o.length>0&&e.harvest(o[0])===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}}};exports.loop=function(){var r;!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`🧹 Cleaned up memory for dead creep: ${e}`))}(),function(){if(Game.time%10==0)for(const o of Object.values(Game.rooms)){const r=e(o);for(const e of Object.keys(r)){const o=r[e],t=Object.values(Game.creeps).filter((o=>o.memory.role!==e&&(!o.memory.lockUntil||Game.time>=o.memory.lockUntil)&&s(o,e))),n={harvester:0,upgrader:0,builder:0};for(const e of Object.values(Game.creeps))n[e.memory.role]=(n[e.memory.role]||0)+1;if(n[e]>=o)continue;const c=t.find((e=>n[e.memory.role]>r[e.memory.role]));if(c){console.log(`🔁 ${c.name}: ${c.memory.role} → ${e}`),c.memory.role=e,c.memory.lockUntil=Game.time+100;break}}}}();const n=Object.values(Game.spawns)[0];n&&function(r){const t=e(r.room);if(console.log("demand:",JSON.stringify(t)),0===Object.values(Game.creeps).filter((e=>"harvester"===e.memory.role)).length&&r.store[RESOURCE_ENERGY]>=200){const e=`emergency_harvester_${Game.time}`;if(r.spawnCreep([WORK,CARRY,MOVE],e,{memory:{role:"harvester"}})===OK)return void console.log(`🆘 Emergency harvester spawned: ${e}`)}for(const e of Object.keys(t)){const n=t[e];if(Object.values(Game.creeps).filter((o=>o.memory.role===e)).length<n){const t=`${e}_${Game.time}`;if(r.spawnCreep(o[e],t,{memory:{role:e}})===OK){console.log(`Spawning ${e}: ${t}`);break}}}}(n);for(const e of Object.values(Game.rooms))t(e);for(const e in Game.creeps){const o=Game.creeps[e],t=o.memory.role;null===(r=c[t])||void 0===r||r.run(o)}};
