"use strict";var e;function o(e){var o,r;const t=null!==(r=null===(o=e.controller)||void 0===o?void 0:o.level)&&void 0!==r?r:0;if(t<2)return 1;const n=e.find(FIND_SOURCES).length,i=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,s=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length;return i<5||s<n?2:t<3?2.5:3===t?3:3.5}function r(e){const o={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const r of Object.values(Game.creeps)){if(r.room.name!==e.name)continue;const t=r.memory.role;void 0!==o[t]&&o[t]++}return o}function t(e){return e.memory.resourceStats&&e.memory.resourceStats.tickLastUpdated===Game.time||function(e){e.memory.resourceStats||(e.memory.resourceStats={energyInStructures:0,energyInPiles:0,energyInTransit:0,totalEnergy:0,energyAvailable:0,energyCapacityAvailable:0,tickLastUpdated:0});const o=e.memory.resourceStats,r=e.find(FIND_STRUCTURES).reduce(((e,o)=>"store"in o&&o.store.getUsedCapacity(RESOURCE_ENERGY)>0?e+o.store.getUsedCapacity(RESOURCE_ENERGY):e),0),t=e.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY}).reduce(((e,o)=>e+o.amount),0),n=e.find(FIND_MY_CREEPS).reduce(((e,o)=>{var r;return e+((null===(r=o.store)||void 0===r?void 0:r.getUsedCapacity(RESOURCE_ENERGY))||0)}),0),i=r+t+n;o.energyInStructures=r,o.energyInPiles=t,o.energyInTransit=n,o.totalEnergy=i,o.energyAvailable=e.energyAvailable,o.energyCapacityAvailable=e.energyCapacityAvailable,o.tickLastUpdated=Game.time}(e),e.memory.resourceStats}function n(e){const o=t(e);console.log(`ðŸ“Š [${e.name}] Energy Stats:\n    âž¡ï¸  Available: ${o.energyAvailable} / ${o.energyCapacityAvailable}\n    ðŸ¦ In Structures: ${o.energyInStructures}\n    ðŸª™ On Ground:     ${o.energyInPiles}\n    ðŸšš In Transit:    ${o.energyInTransit}\n    ðŸ”„ Total Energy:  ${o.totalEnergy}\n    (Updated tick: ${o.tickLastUpdated})\n    `)}Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e.Harvester="harvester",e.Upgrader="upgrader",e.Builder="builder",e.Miner="miner",e.Hauler="hauler"}(e||(e={}));const i=Object.values(e);function s(r){const t=r.find(FIND_SOURCES);return 0===t.length||t.every((t=>{const n=e=>Object.values(Game.creeps).filter((o=>o.room.name===r.name&&o.memory.role===e&&o.memory.sourceId===t.id)).length;if(n(e.Miner)>=1)return!0;const i=n(e.Harvester),s=o(r)<2.5?2:0;return s>0&&i>=s}))}function a(n){const a=o(n),l=n.find(FIND_CONSTRUCTION_SITES).length,c=n.find(FIND_SOURCES),R=c.length,m=2*R,u=i.reduce(((e,o)=>(e[o]=0,e)),{}),E=r(n),d=t(n).energyInPiles;let f;switch(a){case 1:f=Object.assign(Object.assign({},u),{[e.Harvester]:m,[e.Upgrader]:s(n)?1:0});break;case 2:n.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});let o=0;if(n.memory.containerPositions)for(const e of c)if(n.memory.containerPositions[e.id]){const r=n.memory.containerPositions[e.id];n.lookForAt(LOOK_STRUCTURES,r.x,r.y).some((e=>e.structureType===STRUCTURE_CONTAINER))&&o++}const r=R-o;f=Object.assign(Object.assign({},u),{[e.Miner]:o,[e.Hauler]:o>0?Math.max(1,o)+(d>750?1:0):0,[e.Harvester]:2*r,[e.Builder]:s(n)&&l>0?Math.min(2,l):0,[e.Upgrader]:s(n)&&0===l&&(o>0||n.energyAvailable>.5*n.energyCapacityAvailable)?1:0});break;case 2.5:f=Object.assign(Object.assign({},u),{[e.Miner]:R,[e.Hauler]:R+(d>1e3?1:0),[e.Builder]:s(n)&&l>0?Math.min(2,l):0,[e.Upgrader]:s(n)&&0===l?Math.min(3,Math.floor(1.5*n.controller.level)):0});break;default:f=Object.assign(Object.assign({},u),{[e.Miner]:R,[e.Hauler]:R+(d>1e3?1:0),[e.Builder]:s(n)&&l>0?Math.min(3,Math.ceil(l/5)):0,[e.Upgrader]:s(n)&&0===l?Math.min(6,Math.max(1,8-n.controller.level)):0})}d>1e3&&f[e.Hauler]<R+1&&(f[e.Hauler]=(f[e.Hauler]||0)+1,f[e.Hauler]=Math.min(f[e.Hauler],R+2)),n.energyAvailable<.3*n.energyCapacityAvailable&&E[e.Builder]>0&&l>0&&(f[e.Builder]=Math.max(0,(f[e.Builder]||0)-1));const y=n.memory.roleDemandOverrides||{};for(const e of i)void 0!==y[e]&&null!==y[e]&&(f[e]=y[e]);return f}"undefined"!=typeof Game&&(Game.setRoleDemandOverride=function(e,o,r){e.memory.roleDemandOverrides||(e.memory.roleDemandOverrides={}),e.memory.roleDemandOverrides[o]=r,console.log(`[${e.name}] ðŸ”§ Set role demand override: ${o} -> ${r}`)},Game.clearRoleDemandOverride=function(e,o){const r=e.memory.roleDemandOverrides;r&&void 0!==r[o]&&null!==r[o]?(delete r[o],console.log(`[${e.name}] ðŸ—‘ï¸ Cleared role demand override for: ${o}`),0===Object.keys(r).length&&delete e.memory.roleDemandOverrides):console.log(`[${e.name}] Info: No override found for role ${o} to clear.`)},Game.clearAllDemandOverrides=function(e){e.memory.roleDemandOverrides?(delete e.memory.roleDemandOverrides,console.log(`[${e.name}] ðŸ—‘ï¸ Cleared all role demand overrides.`)):console.log(`[${e.name}] Info: No overrides found to clear.`)});const l={harvester:{ratio:{work:3,carry:1,move:1},minEnergyForRatio:400,fallbackBody:[WORK,WORK,CARRY,MOVE]},miner:{ratio:{work:5,move:1},minEnergyForRatio:550,dontRepeatBody:!0},builder:{ratio:{work:2,carry:2,move:2},minEnergyForRatio:400,fallbackBody:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{ratio:{work:3,carry:2,move:3},minEnergyForRatio:550,fallbackBody:[WORK,WORK,CARRY,MOVE]},hauler:{ratio:{carry:6,move:3},minEnergyForRatio:450,fallbackBody:[CARRY,CARRY,CARRY,CARRY,MOVE,MOVE]}};function c(e){return e.reduce(((e,o)=>e+BODYPART_COST[o]),0)}function R(o){if(o.spawning)return;const t=o.room;!function(o){const t=a(o),n=r(o);o.memory.spawnQueue||(o.memory.spawnQueue=[]);const i=[],s=n[e.Miner]||0,l=o.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(0===s&&o.energyAvailable<=300)return console.log(`[${o.name}] ðŸš¨ Emergency queue rebuild: Prioritizing HARVESTER (no miners, low room energy)`),i.push({role:e.Harvester,timestamp:Game.time}),void(o.memory.spawnQueue=i);for(const o of[e.Miner,e.Hauler]){const e=n[o]||0,r=(t[o]||0)-e;if(r>0)for(let e=0;e<r;e++)i.push({role:o,timestamp:Game.time})}if(l.length>0||o.energyAvailable>=o.energyCapacityAvailable){const o=[e.Upgrader,e.Builder,e.Harvester];for(const r of o){if(r===e.Miner||r===e.Hauler)continue;const o=n[r]||0,s=(t[r]||0)-o;if(s>0)for(let e=0;e<s;e++)i.push({role:r,timestamp:Game.time})}}else Game.time%10==0&&console.log(`[${o.name}] ðŸš« Holding off on Upgraders/Builders/GeneralHarvesters, economy not stable.`);if(o.memory.spawnQueue=i,Game.time%20==0){const e=i.map((e=>e.role)).join(", ")||"empty";console.log(`[${o.name}] â™» Spawn Queue Refreshed: [${e}]. Demand: ${JSON.stringify(t)}`)}}(t);const n=t.memory.spawnQueue;if(!n||0===n.length)return;const i=n[0].role,s=function(o,r){const t=l[o];if(!t){console.log(`ERROR: No RoleConfig found for role: ${o}. Using default [W,C,M].`);const e=[WORK,CARRY,MOVE];return r>=c(e)?e:[]}const n=[],i=[];for(const[e,r]of Object.entries(t.ratio))if(void 0!==BODYPART_COST[e]){i.push(e);for(let o=0;o<r;o++)n.push(e)}else console.log(`ERROR: Invalid body part '${e}' in ratio for role ${o}`);const s=c(n);if(r<t.minEnergyForRatio||0===s){const n=t.fallbackBody||[];if(n.length>0&&r>=c(n))return n;let i=[WORK,CARRY,MOVE];return o===e.Miner&&(i=[WORK,MOVE]),r>=c(i)?i:[]}let a=[];if(t.dontRepeatBody)r>=s&&n.length<=50&&(a=[...n]);else{const e=Math.floor(r/s),o=n.length>0?Math.floor(50/n.length):0,t=Math.min(e,o);for(let e=0;e<t;e++)a.push(...n);let l=r-t*s;if(a.length<50){let e;do{e=!1;for(const o of i){const r=BODYPART_COST[o];if(l>=r&&a.length<50&&(a.push(o),l-=r,e=!0),a.length>=50)break}}while(e&&a.length<50)}}const R={[TOUGH]:1,[WORK]:2,[ATTACK]:3,[RANGED_ATTACK]:4,[CARRY]:5,[MOVE]:6,[HEAL]:7,[CLAIM]:8};return a.sort(((e,o)=>(R[e]||99)-(R[o]||99))),0===a.length&&t.fallbackBody&&r>=c(t.fallbackBody)?t.fallbackBody:a}(i,t.energyAvailable);if(0===s.length)return void(Game.time%10==0&&console.log(`[${t.name}] âš ï¸ Insufficient energy (${t.energyAvailable}) for role ${i}. Required body too expensive. Waiting...`));const R={[e.Harvester]:"hrv",[e.Builder]:"bld",[e.Upgrader]:"upg",[e.Miner]:"min",[e.Hauler]:"hul"}[i]||i.substring(0,3),m=function(e){if(!e||0===e.length)return"empty";const o={};for(const r of e)o[r]=(o[r]||0)+1;return[TOUGH,WORK,CARRY,MOVE,ATTACK,RANGED_ATTACK,HEAL,CLAIM].filter((e=>o[e]&&o[e]>0)).map((e=>`${o[e]}${e[0]}`)).join("")}(s),u=`${R}_${m}_${Game.time%1e3}`,E={role:i};let d=OK;if(i===e.Harvester||i===e.Miner){const r=i===e.Miner?1:2,n=function(e,o,r=2){const t=e.find(FIND_SOURCES),n={};for(const e of t)n[e.id]=0;for(const r in Game.creeps){const t=Game.creeps[r];t.room.name===e.name&&t.memory.role===o&&t.memory.sourceId&&void 0!==n[t.memory.sourceId]&&n[t.memory.sourceId]++}const i=t.find((e=>n[e.id]<r));return(null==i?void 0:i.id)||null}(o.room,i,r);n?E.sourceId=n:console.log(`[${t.name}] âš ï¸ CRITICAL: No available source for spawning ${i} ${u}. Spawning without target!`)}else if(i===e.Hauler){const r=function(o){const r=o.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});if(0===r.length)return null;const t={};for(const e of r)t[e.id]=0;for(const r in Game.creeps){const n=Game.creeps[r];n.room.name===o.name&&n.memory.role===e.Hauler&&n.memory.containerId&&void 0!==t[n.memory.containerId]&&t[n.memory.containerId]++}const n=r.find((e=>t[e.id]<1));return(null==n?void 0:n.id)||null}(o.room);r?E.containerId=r:t.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length>0&&console.log(`[${t.name}] INFO: No specific unassigned container for ${i} ${u}. It will find work or use handleIdle.`)}var f;d=o.spawnCreep(s,u,{memory:E}),d===OK?(console.log(`[${t.name}] âœ… Spawning ${i}: ${u} with body [${s.join(",")}]`),n.shift(),t.memory.spawnQueue=n):d===ERR_NOT_ENOUGH_ENERGY?Game.time%10==0&&console.log(`[${t.name}] âš ï¸ Spawn attempt for ${u} failed: ERR_NOT_ENOUGH_ENERGY. Available: ${t.energyAvailable}, Cost: ${f=s,f.reduce(((e,o)=>e+BODYPART_COST[o]),0)} (This check should be redundant)`):d!==ERR_BUSY&&console.log(`[${t.name}] âŒ Spawn attempt for ${u} failed with error: ${d}`)}const m=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function u(e){if(Game.time%10!=0)return;switch(o(e)){case 2:E(e),function(e){const o=e.find(FIND_MY_SPAWNS)[0];if(!o)return;e.memory.containerPositions||(e.memory.containerPositions={});for(const r of e.find(FIND_SOURCES)){const t=e.memory.containerPositions[r.id];if(t){const o=e.lookForAt(LOOK_STRUCTURES,t.x,t.y).some((e=>e.structureType===STRUCTURE_CONTAINER)),n=e.lookForAt(LOOK_CONSTRUCTION_SITES,t.x,t.y).some((e=>e.structureType===STRUCTURE_CONTAINER));if(o||n)continue;delete e.memory.containerPositions[r.id],console.log(`âš ï¸ Container for source ${r.id} missing, memory cleared`)}console.log("no memory of this source having a container",r);const n=d.map((([o,t])=>new RoomPosition(r.pos.x+o,r.pos.y+t,e.name))).filter((o=>e.getTerrain().get(o.x,o.y)!==TERRAIN_MASK_WALL&&(!(o.lookFor(LOOK_STRUCTURES).length>0)&&!(o.lookFor(LOOK_CONSTRUCTION_SITES).length>0))));if(0===n.length)continue;n.sort(((e,r)=>o.pos.getRangeTo(e)-o.pos.getRangeTo(r)));const i=n[0],s=e.createConstructionSite(i.x,i.y,STRUCTURE_CONTAINER);s===OK?(e.memory.containerPositions[r.id]={x:i.x,y:i.y},console.log(`âœï¸ Placed container for source ${r.id} at (${i.x},${i.y})`)):console.log(`âŒ Failed to place container at (${i.x},${i.y}): ${s}`)}}(e);break;case 2.5:!function(e){var o;const r=e.find(FIND_MY_SPAWNS)[0],t=e.controller;if(!r||!t)return;if(!e.memory.roadSitesPlanned){const s=[];function a(e){for(const o of e)o.x,o.y,s.find((e=>e.x===o.x&&e.y===o.y))||s.push({x:o.x,y:o.y})}const l=e.find(FIND_SOURCES);for(const c of l){const R=null===(o=e.memory.containerPositions)||void 0===o?void 0:o[c.id];if(!R)continue;const m=new RoomPosition(R.x,R.y,e.name);a(PathFinder.search(m,{pos:r.pos,range:1},{plainCost:2,swampCost:10,roomCallback:e=>{const o=Game.rooms[e];if(!o)return!1;const r=new PathFinder.CostMatrix;return o.find(FIND_STRUCTURES).forEach((e=>{e.structureType===STRUCTURE_ROAD&&r.set(e.pos.x,e.pos.y,1)})),r}}).path)}a(PathFinder.search(r.pos,{pos:t.pos,range:3},{plainCost:2,swampCost:10}).path),e.memory.roadSitesPlanned=s}const n=e.memory.roadSitesPlanned;let i=0;for(const{x:u,y:E}of n){if(i>=5)break;const d=new RoomPosition(u,E,e.name);d.lookFor(LOOK_STRUCTURES).some((e=>e.structureType===STRUCTURE_ROAD))||d.lookFor(LOOK_CONSTRUCTION_SITES).some((e=>e.structureType===STRUCTURE_ROAD))||e.createConstructionSite(u,E,STRUCTURE_ROAD)===OK&&i++}}(e);break;case 3:E(e)}}function E(e){const o=e.controller;if(!o||!o.my||o.level<2)return;const r=CONTROLLER_STRUCTURES.extension[o.level]-(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length+e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length);if(r<=0)return;const t=e.find(FIND_MY_SPAWNS)[0];if(!t)return;let n=0;for(const[o,i]of m){if(n>=r)return;const s=t.pos.x+o,a=t.pos.y+i;if(!(e.lookForAt(LOOK_STRUCTURES,s,a).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,s,a).length>0)){e.createConstructionSite(s,a,STRUCTURE_EXTENSION)===OK&&n++}}}const d=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];class f{collectEnergy(e){const o=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(o)return void(e.pickup(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}}));const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(r.length>0){const o=e.pos.findClosestByPath(r);return void(o&&e.withdraw(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}}))}const t=e.room.find(FIND_SOURCES_ACTIVE);if(t.length>0){const o=e.pos.findClosestByPath(t);o&&e.harvest(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}})}}updateWorkingState(e){e.memory.atCapacity&&0===e.store[RESOURCE_ENERGY]&&(e.memory.atCapacity=!1,e.say("ðŸ”„ harvest")),e.memory.atCapacity||0!==e.store.getFreeCapacity()||(e.memory.atCapacity=!0,e.say("âš¡ deliver"))}deliverEnergy(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(o.length>0){const r=e.pos.findClosestByPath(o);r&&e.transfer(r,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ffffff"}})}else e.say("ðŸ¤·â€â™‚ï¸ full?")}}function y(e){if(e.store.getFreeCapacity(RESOURCE_ENERGY)>0){const o=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(o)return void(e.pickup(o)===ERR_NOT_IN_RANGE&&e.moveTo(o))}const o=e.room.find(FIND_CONSTRUCTION_SITES);if(o.length>0){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY)){const r=e.pos.findClosestByPath(o);return void(r&&e.build(r)===ERR_NOT_IN_RANGE&&e.moveTo(r))}{const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0});if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}}const t=e.room.controller;if(t&&function(e){const o=a(e),t=r(e);for(const e of i)if(t[e]<(o[e]||0))return!1;return!0}(e.room)){const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0}),r=200;if(o.reduce(((e,o)=>e+o.store[RESOURCE_ENERGY]),0)>=r||e.room.energyAvailable>=r){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY))return void(e.upgradeController(t)===ERR_NOT_IN_RANGE&&e.moveTo(t));if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}}e.say("ðŸª‘ idle")}const T={[STRUCTURE_CONTAINER]:{pct:.8},[STRUCTURE_ROAD]:{pct:.5},[STRUCTURE_EXTENSION]:{pct:.8}};const S={harvester:new class extends f{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performDelivery(e):this.performHarvest(e)}performHarvest(e){let o=null;if(e.memory.sourceId&&(o=Game.getObjectById(e.memory.sourceId),o||(delete e.memory.sourceId,o=null)),!o){const r=e.room.find(FIND_SOURCES_ACTIVE);r.length>0&&(o=e.pos.findClosestByPath(r),o&&(e.memory.sourceId=o.id,e.say("ðŸ”„ New Src")))}if(o){const r=e.harvest(o);r===ERR_NOT_IN_RANGE?e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}}):r===OK||(r===ERR_NOT_ENOUGH_RESOURCES?(delete e.memory.sourceId,e.say("â›ï¸ Empty")):r===ERR_NO_BODYPART&&e.say("ðŸ’” No WORK"))}else e.say("â“ No Src"),y(e)}performDelivery(e){if(super.deliverEnergy(e),e.store.getUsedCapacity(RESOURCE_ENERGY)>0){e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0}).length>0||(e.say("ðŸšš IdleFull"),y(e))}}},builder:new class extends f{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performWork(e):super.collectEnergy(e)}performWork(e){this.tryPriorityRepair(e)||this.tryBuild(e)||this.tryGeneralRepair(e)||(e.say("ðŸ‘· Idle"),y(e))}tryPriorityRepair(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)return!1;const o=T[e.structureType];return!!o&&(null!=o.pct&&e.hits<e.hitsMax*o.pct||null!=o.hp&&e.hits<o.hp)}});if(o.length>0){const r=e.pos.findClosestByPath(o);if(r)return e.say("ðŸ› ï¸ Prior"),e.repair(r)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ff0000"}}),!0}return!1}tryBuild(e){const o=e.room.find(FIND_CONSTRUCTION_SITES);if(o.length>0){const r=e.pos.findClosestByPath(o);if(r)return e.say("ðŸš§ Build"),e.build(r)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ffffff"}}),!0}return!1}tryGeneralRepair(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_WALL&&e.structureType!==STRUCTURE_RAMPART&&e.hits<e.hitsMax});if(o.length>0){const r=e.pos.findClosestByPath(o);if(r)return e.say("ðŸ”§ Repair"),e.repair(r)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}}),!0}return!1}},upgrader:new class extends f{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performUpgrade(e):super.collectEnergy(e)}performUpgrade(e){const o=e.room.controller;if(o&&o.my){const r=e.upgradeController(o);r===ERR_NOT_IN_RANGE?e.moveTo(o,{visualizePathStyle:{stroke:"#4CAF50"},range:3}):r===OK||(r===ERR_NOT_ENOUGH_RESOURCES?(e.memory.atCapacity=!1,e.say("â›ï¸ Empty!")):e.say(`âš ï¸ UpgErr ${r}`))}else e.say("â“ No Ctrlr"),y(e)}},miner:new class extends f{run(e){if(!this.hasValidAssignments(e))return;const{x:o,y:r}=e.room.memory.containerPositions[e.memory.sourceId],t=new RoomPosition(o,r,e.room.name);e.pos.isEqualTo(t)?this.performHarvesting(e):this.moveToDesignatedPosition(e,t)}hasValidAssignments(e){const o=e.memory.sourceId;if(!o)return e.say("â“NoSrcID"),console.log(`Miner ${e.name} is missing sourceId.`),!1;const r=e.room.memory.containerPositions;return!(!r||!r[o])||(e.say("âŒNoSpot"),console.log(`Miner ${e.name} (source: ${o}) is missing a designated containerPosition in room memory.`),!1)}moveToDesignatedPosition(e,o){e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"},range:0})}performHarvesting(e){const o=Game.getObjectById(e.memory.sourceId);if(!o)return e.say("â“SrcGone"),console.log(`Miner ${e.name} assigned source ${e.memory.sourceId} no longer exists or is not visible.`),void delete e.memory.sourceId;const r=e.harvest(o);r===OK||(r===ERR_NOT_ENOUGH_RESOURCES?e.say("â›ï¸Empty"):r===ERR_BUSY||(r===ERR_NO_BODYPART?(e.say("ðŸ’”NoWORK"),console.log(`Miner ${e.name} has no WORK parts.`)):r===ERR_NOT_OWNER?e.say("ðŸ¢NotMyCtrlr"):r===ERR_INVALID_TARGET?(e.say("âŒInvTrg"),console.log(`Miner ${e.name} has invalid harvest target: ${o}`),delete e.memory.sourceId):(e.say(`ðŸ’€HrvFail:${r}`),console.log(`Miner ${e.name} failed to harvest source ${o.id} with error: ${r}`))))}},hauler:new class extends f{run(e){if(this.updateWorkingState(e),e.memory.atCapacity){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(o.length>0)return void(e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}const o=e.memory.containerId,r=o?Game.getObjectById(o):null;r&&r.store.getUsedCapacity(RESOURCE_ENERGY)>0?e.withdraw(r,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r):y(e)}}},p=function(e,o){const r=Game.cpu.getUsed(),t=o(),n=Game.cpu.getUsed()-r;return console.log(`ðŸ“Š ${e}: ${n.toFixed(2)} CPU`),t}("main loop",(function(){!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`ðŸ§¹ Cleaned up memory for dead creep: ${e}`))}();const e=Object.values(Game.spawns)[0];e&&R(e);for(const e in Game.rooms){const o=Game.rooms[e];u(o),Game.time%10==0&&n(o)}for(const e in Game.creeps){const o=Game.creeps[e];if(!o.spawning){const e=o.memory.role;e&&S[e]?S[e].run(o):console.log(`Creep ${o.name} has an unknown or undefined role: ${e}`)}}}));exports.loop=p;
