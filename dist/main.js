"use strict";var e;function o(e){var o,r;const t=null!==(r=null===(o=e.controller)||void 0===o?void 0:o.level)&&void 0!==r?r:0;if(t<2)return 1;const n=e.find(FIND_SOURCES).length,s=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,i=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length;return s<5||i<n?2:t<3?2.5:3===t?3:3.5}function r(e){const o={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const r of Object.values(Game.creeps)){if(r.room.name!==e.name)continue;const t=r.memory.role;void 0!==o[t]&&o[t]++}return o}Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e.Harvester="harvester",e.Upgrader="upgrader",e.Builder="builder",e.Miner="miner",e.Hauler="hauler"}(e||(e={}));const t=Object.values(e);function n(o){return o.find(FIND_SOURCES).every((r=>{const t=e=>e.room.name===o.name,n=e=>e.memory.sourceId===r.id;if(Object.values(Game.creeps).filter((o=>t(o)&&o.memory.role===e.Miner&&n(o))).length>=1)return!0;return Object.values(Game.creeps).filter((o=>t(o)&&o.memory.role===e.Harvester&&n(o))).length>=2}))}function s(e){const r=o(e),s=e.find(FIND_CONSTRUCTION_SITES).length,i=e.find(FIND_SOURCES),a=2*i.length,c=t.reduce(((e,o)=>(e[o]=0,e)),{});let l;switch(r){case 1:l=Object.assign(Object.assign({},c),{harvester:a,upgrader:n(e)?1:0});break;case 2:const o=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});l=Object.assign(Object.assign({},c),{harvester:o.length>=1?a/2:a,builder:n(e)&&s>0?2:1,hauler:o.length>=1?1:0,miner:o.length>=1?1:0});break;case 2.5:l=Object.assign(Object.assign({},c),{miner:i.length,hauler:i.length+1,builder:n(e)?2:0,upgrader:n(e)&&s>0?0:10});break;default:l=Object.assign(Object.assign({},c),{harvester:a,builder:s>0?1:0,upgrader:s>0?0:1})}const R=e.memory.roleDemandOverrides||{};for(const e of t)null!=R[e]&&(l[e]=R[e]);return l}Object.assign(Game,{setRoleDemandOverride:function(e,o,r){e.memory.roleDemandOverrides||(e.memory.roleDemandOverrides={}),e.memory.roleDemandOverrides[o]=r,console.log(`🔧 [${e.name}] override ${o} → ${r}`)},clearRoleDemandOverride:function(e,o){const r=e.memory.roleDemandOverrides;r&&null!=r[o]&&(delete r[o],console.log(`🗑️ [${e.name}] cleared override for ${o}`))},clearAllDemandOverrides:function(e){e.memory.roleDemandOverrides={},console.log(`🗑️ [${e.name}] cleared all role-demand overrides`)}});const i={harvester:{ratio:{work:3,carry:1,move:1},minEnergyForRatio:400,fallbackBody:[WORK,WORK,CARRY,MOVE]},miner:{ratio:{work:5,move:1},minEnergyForRatio:550,dontRepeatBody:!0},builder:{ratio:{work:2,carry:2,move:2},minEnergyForRatio:400,fallbackBody:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{ratio:{work:3,carry:2,move:3},minEnergyForRatio:550,fallbackBody:[WORK,WORK,CARRY,MOVE]},hauler:{ratio:{carry:6,move:3},minEnergyForRatio:450}};function a(o){const t=o.room;!function(o){const t=s(o),n=r(o);o.memory.spawnQueue||(o.memory.spawnQueue=[]);const i=o.memory.spawnQueue,a=Object.values(e).reduce(((e,o)=>(e[o]=0,e)),{});for(const e of i)a[e.role]=(a[e.role]||0)+1;for(const o of Object.values(e)){const e=n[o]||0,r=a[o]||0,s=t[o]-e-r;for(let e=0;e<s;e++)i.push({role:o,timestamp:Game.time})}Game.time%10==0&&console.log(`queue (${Game.time}):`,JSON.stringify(i))}(t);const n=s(t),a=t.memory.spawnQueue;if(0===a.length)return;Game.time%10==0&&console.log("demand:\n"+JSON.stringify(n,null,2));const c=a[0],l=c.role,R=function(e,o){const r=i[e];if(!r)return[WORK,CARRY,MOVE];const t=[],n=[];for(const[e,o]of Object.entries(r.ratio)){n.push(e);for(let r=0;r<o;r++)t.push(e)}const s=t.reduce(((e,o)=>e+BODYPART_COST[o]),0);if(o<r.minEnergyForRatio||0===s)return r.fallbackBody||[];const a=r.dontRepeatBody?1:Math.floor(o/s),c=Math.min(a,Math.floor(50/t.length)),l=[];for(let e=0;e<c*t.length;e++)l.push(t[e%t.length]);let R,u=o-c*s;do{R=!1;for(const e of n){const o=BODYPART_COST[e];u>=o&&l.length<50&&(l.push(e),u-=o,R=!0)}}while(R);return l}(c.role,t.energyAvailable);if(0===R.length)return;const u=function(e){const o={work:0,carry:0,move:0,attack:0,ranged_attack:0,tough:0,heal:0,claim:0};for(const r of e)o[r]++;return Object.entries(o).filter((([e,o])=>o>0)).map((([e,o])=>`${o}${e[0]}`)).join("")}(R),m=`${{harvester:"hr",builder:"b",upgrader:"u",miner:"m",hauler:"hl"}[l]||l}_${u}_${Game.time}`;let E;if(l===e.Harvester||l===e.Miner){const r=l===e.Miner?1:2,t=function(e,o,r=2){const t=e.find(FIND_SOURCES),n={};for(const e of t)n[e.id]=0;for(const e of Object.values(Game.creeps))e.memory.role===o&&e.memory.sourceId&&(n[e.memory.sourceId]=(n[e.memory.sourceId]||0)+1);const s=t.find((e=>n[e.id]<r));return(null==s?void 0:s.id)||null}(o.room,l,r);if(!t)return void console.log("❌ No available source for role"+l);E=o.spawnCreep(R,m,{memory:{role:l,sourceId:t}}),E===OK&&console.log(`Spawning ${l}: ${m} → source ${t}`)}else if(l===e.Hauler){const e=function(e){const o=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}),r={};for(const e of o)r[e.id]=0;for(const e of Object.values(Game.creeps))"hauler"===e.memory.role&&e.memory.containerId&&(r[e.memory.containerId]=(r[e.memory.containerId]||0)+1);const t=o.find((e=>r[e.id]<1));return(null==t?void 0:t.id)||null}(o.room);E=o.spawnCreep(R,m,{memory:{role:l,containerId:e}}),E===OK&&console.log(`Spawning hauler: ${m} → container ${e}`)}else E=o.spawnCreep(R,m,{memory:{role:l}}),E===OK&&console.log(`Spawning ${l}: ${m}`);E===OK&&(t.memory.spawnQueue=a.slice(1))}const c=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function l(e){if(Game.time%10!=0)return;switch(o(e)){case 2:R(e),function(e){const o=e.find(FIND_MY_SPAWNS)[0];if(!o)return;e.memory.containerPositions||(e.memory.containerPositions={});for(const r of e.find(FIND_SOURCES)){if(e.memory.containerPositions[r.id])continue;console.log("no memory of this source having a container",r);const t=u.map((([o,t])=>new RoomPosition(r.pos.x+o,r.pos.y+t,e.name))).filter((o=>e.getTerrain().get(o.x,o.y)!==TERRAIN_MASK_WALL&&(!(o.lookFor(LOOK_STRUCTURES).length>0)&&!(o.lookFor(LOOK_CONSTRUCTION_SITES).length>0))));if(0===t.length)continue;t.sort(((e,r)=>o.pos.getRangeTo(e)-o.pos.getRangeTo(r)));const n=t[0],s=e.createConstructionSite(n.x,n.y,STRUCTURE_CONTAINER);s===OK?(e.memory.containerPositions[r.id]={x:n.x,y:n.y},console.log(`✏️ Placed container for source ${r.id} at (${n.x},${n.y})`)):console.log(`❌ Failed to place container at (${n.x},${n.y}): ${s}`)}}(e);break;case 2.5:!function(e){var o;const r=e.find(FIND_MY_SPAWNS)[0],t=e.controller;if(!r||!t)return;if(!e.memory.roadSitesPlanned){const i=[];function a(e){for(const o of e)o.x,o.y,i.find((e=>e.x===o.x&&e.y===o.y))||i.push({x:o.x,y:o.y})}const c=e.find(FIND_SOURCES);for(const l of c){const R=null===(o=e.memory.containerPositions)||void 0===o?void 0:o[l.id];if(!R)continue;const u=new RoomPosition(R.x,R.y,e.name);a(PathFinder.search(u,{pos:r.pos,range:1},{plainCost:2,swampCost:10,roomCallback:e=>{const o=Game.rooms[e];if(!o)return!1;const r=new PathFinder.CostMatrix;return o.find(FIND_STRUCTURES).forEach((e=>{e.structureType===STRUCTURE_ROAD&&r.set(e.pos.x,e.pos.y,1)})),r}}).path)}a(PathFinder.search(r.pos,{pos:t.pos,range:3},{plainCost:2,swampCost:10}).path),e.memory.roadSitesPlanned=i}const n=e.memory.roadSitesPlanned;let s=0;for(const{x:m,y:E}of n){if(s>=5)break;const f=new RoomPosition(m,E,e.name);f.lookFor(LOOK_STRUCTURES).some((e=>e.structureType===STRUCTURE_ROAD))||f.lookFor(LOOK_CONSTRUCTION_SITES).some((e=>e.structureType===STRUCTURE_ROAD))||e.createConstructionSite(m,E,STRUCTURE_ROAD)===OK&&s++}}(e);break;case 3:R(e)}}function R(e){const o=e.controller;if(!o||!o.my||o.level<2)return;const r=CONTROLLER_STRUCTURES.extension[o.level]-(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length+e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length);if(r<=0)return;const t=e.find(FIND_MY_SPAWNS)[0];if(!t)return;let n=0;for(const[o,s]of c){if(n>=r)return;const i=t.pos.x+o,a=t.pos.y+s;if(!(e.lookForAt(LOOK_STRUCTURES,i,a).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,i,a).length>0)){e.createConstructionSite(i,a,STRUCTURE_EXTENSION)===OK&&n++}}}const u=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];class m{collectEnergy(e){const o=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(o)return void(e.pickup(o)===ERR_NOT_IN_RANGE&&e.moveTo(o));const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]));const t=e.room.find(FIND_SOURCES);t.length>0&&e.harvest(t[0])===ERR_NOT_IN_RANGE&&e.moveTo(t[0])}updateWorkingState(e){e.memory.atCapacity&&0===e.store[RESOURCE_ENERGY]&&(e.memory.atCapacity=!1),e.memory.atCapacity||0!==e.store.getFreeCapacity()||(e.memory.atCapacity=!0)}deliverEnergy(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});o.length>0&&e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}}function E(e){if(e.store.getFreeCapacity(RESOURCE_ENERGY)>0){const o=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(o)return void(e.pickup(o)===ERR_NOT_IN_RANGE&&e.moveTo(o))}const o=e.room.find(FIND_CONSTRUCTION_SITES);if(o.length>0){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY)){const r=e.pos.findClosestByPath(o);return void(r&&e.build(r)===ERR_NOT_IN_RANGE&&e.moveTo(r))}{const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0});if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}}const n=e.room.controller;if(n&&function(e){const o=s(e),n=r(e);for(const e of t)if(n[e]<o[e])return!1;return!0}(e.room)){const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0}),r=200;if(o.reduce(((e,o)=>e+o.store[RESOURCE_ENERGY]),0)>=r||e.room.energyAvailable>=r){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY))return void(e.upgradeController(n)===ERR_NOT_IN_RANGE&&e.moveTo(n));if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}}e.say("🪑 idle")}const f={harvester:new class extends m{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.deliverEnergy(e):this.harvest(e)}harvest(e){const o=e.memory.sourceId;let r=o?Game.getObjectById(o):null;if(!r){if(r=e.pos.findClosestByPath(FIND_SOURCES),!r)return void e.say("❓ no src");e.memory.sourceId=r.id,e.say("🔁")}e.harvest(r)===ERR_NOT_IN_RANGE&&e.moveTo(r)}},builder:new class extends m{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.buildOrRepair(e):this.collectEnergy(e)}buildOrRepair(e){const o={[STRUCTURE_CONTAINER]:{pct:.8},[STRUCTURE_ROAD]:{hp:5e3},[STRUCTURE_EXTENSION]:{pct:.8}},r=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)return!1;const r=o[e.structureType];if(!r)return!1;const t=e.hitsMax-e.hits;return null!=r.pct&&e.hits<e.hitsMax*r.pct||null!=r.hp&&t>r.hp}});if(r.length>0){const o=e.pos.findClosestByRange(r);return void(o&&e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ff0000"}}))}const t=e.room.find(FIND_CONSTRUCTION_SITES);if(t.length>0){const o=e.pos.findClosestByRange(t);return void(o&&e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}}))}const n=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_WALL&&e.structureType!==STRUCTURE_RAMPART&&e.hits<e.hitsMax});if(n.length>0){const o=e.pos.findClosestByRange(n);return void(o&&e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}}))}const s=e.room.find(FIND_MY_SPAWNS)[0];s&&e.moveTo(s)}},upgrader:new class extends m{run(e){this.updateWorkingState(e),e.memory.atCapacity?e.upgradeController(e.room.controller)===ERR_NOT_IN_RANGE&&e.moveTo(e.room.controller):this.collectEnergy(e)}},miner:new class extends m{run(e){const o=e.memory.sourceId,r=e.room.memory.containerPositions;if(!o)return void e.say("❓ no src");if(!r||!r[o])return void e.say("❌ no pos");const{x:t,y:n}=r[o],s=new RoomPosition(t,n,e.room.name);if(!e.pos.isEqualTo(s))return void e.moveTo(s,{visualizePathStyle:{stroke:"#ffaa00"}});const i=Game.getObjectById(o);if(!i)return void e.say("❓ src gone");e.harvest(i)!==OK&&e.say("💀 fail")}},hauler:new class extends m{run(e){if(this.updateWorkingState(e),e.memory.atCapacity){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(o.length>0)return void(e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}const o=e.memory.containerId?Game.getObjectById(e.memory.containerId):null;o&&o.store[RESOURCE_ENERGY]>0?e.withdraw(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o):E(e)}}},d=function(e,o){const r=Game.cpu.getUsed(),t=o(),n=Game.cpu.getUsed()-r;return console.log(`📊 ${e}: ${n.toFixed(2)} CPU`),t}("main loop",(function(){var e;!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`🧹 Cleaned up memory for dead creep: ${e}`))}();const o=Object.values(Game.spawns)[0];o&&a(o);for(const e of Object.values(Game.rooms))l(e);for(const o in Game.creeps){const r=Game.creeps[o],t=r.memory.role;null===(e=f[t])||void 0===e||e.run(r)}}));exports.loop=d;
