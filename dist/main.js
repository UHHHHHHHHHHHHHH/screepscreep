"use strict";var e;function o(e){var o,r;if((null!==(r=null===(o=e.controller)||void 0===o?void 0:o.level)&&void 0!==r?r:0)<2)return 1;const t=e.find(FIND_SOURCES).length,n=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,i=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length;return n<5||i<t?2:2.5}Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e.Harvester="harvester",e.Upgrader="upgrader",e.Builder="builder",e.Miner="miner",e.Hauler="hauler"}(e||(e={}));const r=Object.values(e);function t(o){return o.find(FIND_SOURCES).every((r=>{const t=e=>e.room.name===o.name,n=e=>e.memory.sourceId===r.id;if(Object.values(Game.creeps).filter((o=>t(o)&&o.memory.role===e.Miner&&n(o))).length>=1)return!0;return Object.values(Game.creeps).filter((o=>t(o)&&o.memory.role===e.Harvester&&n(o))).length>=2}))}function n(n){const i=o(n),s=n.find(FIND_CONSTRUCTION_SITES).length,l=n.find(FIND_SOURCES),a=2*l.length;Object.values(Game.creeps).filter((o=>o.memory.role===e.Harvester&&o.room.name===n.name)).length;const c=r.reduce(((e,o)=>(e[o]=0,e)),{});switch(i){case 1:return Object.assign(Object.assign({},c),{harvester:a,upgrader:t(n)?1:0});case 2:const e=n.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});return Object.assign(Object.assign({},c),{harvester:e.length>=1?a/2:a,builder:t(n)&&s>0?1:0,hauler:e.length>=1?1:0,miner:e.length>=1?1:0});case 2.5:return Object.assign(Object.assign({},c),{miner:l.length,hauler:l.length,builder:s>0?1:0,upgrader:1});default:return Object.assign(Object.assign({},c),{harvester:a,builder:s>0?1:0,upgrader:s>0?0:1})}}const i={harvester:{ratio:{work:3,carry:1,move:1},minEnergyForRatio:400,fallbackBody:[WORK,CARRY,CARRY,MOVE,MOVE]},miner:{ratio:{work:5,move:1},minEnergyForRatio:550,fallbackRole:e.Harvester,fallbackBody:[WORK,CARRY,MOVE]},builder:{ratio:{work:1,carry:2,move:2},minEnergyForRatio:300,fallbackBody:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{ratio:{work:2,carry:2,move:1},minEnergyForRatio:350,fallbackBody:[WORK,CARRY,MOVE]},hauler:{ratio:{carry:6,move:3},minEnergyForRatio:450,fallbackBody:[CARRY,CARRY,MOVE,MOVE]}};function s(e,o){const r=i[e];if(!r)return[WORK,CARRY,MOVE];const t=[];for(const[e,o]of Object.entries(r.ratio))for(let r=0;r<o;r++)t.push(e);const n=t.reduce(((e,o)=>e+BODYPART_COST[o]),0);if(o<r.minEnergyForRatio||0===n)return r.fallbackRole?[]:r.fallbackBody||[];const s=Math.floor(o/n),l=Math.min(s,Math.floor(50/t.length)),a=[];for(let e=0;e<l*t.length;e++)a.push(t[e%t.length]);return a}function l(e){const o={work:0,carry:0,move:0,attack:0,ranged_attack:0,tough:0,heal:0,claim:0};for(const r of e)o[r]++;return Object.entries(o).filter((([e,o])=>o>0)).map((([e,o])=>`${o}${e[0]}`)).join("")}function a(e,o,r=2){const t=e.find(FIND_SOURCES),n={};for(const e of t)n[e.id]=0;for(const e of Object.values(Game.creeps))e.memory.role===o&&e.memory.sourceId&&(n[e.memory.sourceId]=(n[e.memory.sourceId]||0)+1);const i=t.find((e=>n[e.id]<r));return(null==i?void 0:i.id)||null}function c(e){const o=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}),r={};for(const e of o)r[e.id]=0;for(const e of Object.values(Game.creeps))"hauler"===e.memory.role&&e.memory.containerId&&(r[e.memory.containerId]=(r[e.memory.containerId]||0)+1);const t=o.find((e=>r[e.id]<1));return(null==t?void 0:t.id)||null}const R=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function m(e){if(Game.time%10!=0)return;if(2===o(e))!function(e){const o=e.controller;if(!o||!o.my||o.level<2)return;const r=CONTROLLER_STRUCTURES.extension[o.level],t=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,n=e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,i=r-(t+n);if(i<=0)return;const s=e.find(FIND_MY_SPAWNS)[0];if(!s)return;let l=0;for(const[o,r]of R){if(l>=i)return;const t=s.pos.x+o,n=s.pos.y+r;if(!(e.lookForAt(LOOK_STRUCTURES,t,n).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,t,n).length>0)){e.createConstructionSite(t,n,STRUCTURE_EXTENSION)===OK&&l++}}}(e),function(e){const o=e.find(FIND_MY_SPAWNS)[0];if(!o)return;e.memory.containerPositions||(e.memory.containerPositions={});for(const r of e.find(FIND_SOURCES)){if(e.memory.containerPositions[r.id])continue;console.log("no memory of this source having a container",r);const t=u.map((([o,t])=>new RoomPosition(r.pos.x+o,r.pos.y+t,e.name))).filter((o=>e.getTerrain().get(o.x,o.y)!==TERRAIN_MASK_WALL&&(!(o.lookFor(LOOK_STRUCTURES).length>0)&&!(o.lookFor(LOOK_CONSTRUCTION_SITES).length>0))));if(0===t.length)continue;t.sort(((e,r)=>o.pos.getRangeTo(e)-o.pos.getRangeTo(r)));const n=t[0],i=e.createConstructionSite(n.x,n.y,STRUCTURE_CONTAINER);i===OK?(e.memory.containerPositions[r.id]={x:n.x,y:n.y},console.log(`âœï¸ Placed container for source ${r.id} at (${n.x},${n.y})`)):console.log(`âŒ Failed to place container at (${n.x},${n.y}): ${i}`)}}(e)}const u=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];class E{collectEnergy(e){if(Object.values(Game.creeps).some((e=>"harvester"===e.memory.role))){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}const o=e.room.find(FIND_SOURCES);o.length>0&&e.harvest(o[0])===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}updateWorkingState(e){e.memory.working&&0===e.store[RESOURCE_ENERGY]&&(e.memory.working=!1),e.memory.working||0!==e.store.getFreeCapacity()||(e.memory.working=!0)}}function f(e,o){const r=s(o,e.room.energyCapacityAvailable),t=e.body.map((e=>e.type)),n=new Set(r);for(const e of n)if(!t.includes(e))return!1;return!0}function T(e){const o=e.room.find(FIND_CONSTRUCTION_SITES);if(o.length>0){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY)){const r=e.pos.findClosestByPath(o);return void(r&&e.build(r)===ERR_NOT_IN_RANGE&&e.moveTo(r))}{const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0});if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}}const r=e.room.controller;if(r&&function(e){const o=n(e),r={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const o of Object.values(Game.creeps))o.room.name===e.name&&(r[o.memory.role]=(r[o.memory.role]||0)+1);for(const e of Object.keys(o))if(r[e]<o[e])return!1;return!0}(e.room)){const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0}),t=200;if(o.reduce(((e,o)=>e+o.store[RESOURCE_ENERGY]),0)>=t||e.room.energyAvailable>=t){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY))return void(e.upgradeController(r)===ERR_NOT_IN_RANGE&&e.moveTo(r));if(o.length>0)return void(e.withdraw(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}}e.say("ðŸª‘ idle")}const d={harvester:new class extends E{run(e){this.updateWorkingState(e),e.memory.working?this.deliverEnergy(e):this.harvest(e)}deliverEnergy(e){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});o.length>0&&e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0])}harvest(e){const o=e.memory.sourceId;let r=o?Game.getObjectById(o):null;if(!r){if(r=e.pos.findClosestByPath(FIND_SOURCES),!r)return void e.say("â“ no src");e.memory.sourceId=r.id,e.say("ðŸ”")}e.harvest(r)===ERR_NOT_IN_RANGE&&e.moveTo(r)}},builder:new class extends E{run(e){this.updateWorkingState(e),e.memory.working?this.buildOrRepair(e):this.collectEnergy(e)}buildOrRepair(e){const o={[STRUCTURE_CONTAINER]:{pct:.8},[STRUCTURE_ROAD]:{hp:5e3},[STRUCTURE_EXTENSION]:{pct:.8}},r=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)return!1;const r=o[e.structureType];if(!r)return!1;const t=e.hitsMax-e.hits;return null!=r.pct&&e.hits<e.hitsMax*r.pct||null!=r.hp&&t>r.hp}});if(r.length>0){const o=e.pos.findClosestByRange(r);return void(o&&e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ff0000"}}))}const t=e.room.find(FIND_CONSTRUCTION_SITES);if(0===t.length){const o=e.room.find(FIND_MY_SPAWNS)[0];return void(o&&e.moveTo(o))}const n=e.pos.findClosestByRange(t);n&&e.build(n)===ERR_NOT_IN_RANGE&&e.moveTo(n,{visualizePathStyle:{stroke:"#ffffff"}})}},upgrader:new class extends E{run(e){this.updateWorkingState(e),e.memory.working?e.upgradeController(e.room.controller)===ERR_NOT_IN_RANGE&&e.moveTo(e.room.controller):this.collectEnergy(e)}},miner:new class extends E{run(e){const o=e.memory.sourceId,r=e.room.memory.containerPositions;if(!o)return void e.say("â“ no src");if(!r||!r[o])return void e.say("âŒ no pos");const{x:t,y:n}=r[o],i=new RoomPosition(t,n,e.room.name);if(!e.pos.isEqualTo(i))return void e.moveTo(i,{visualizePathStyle:{stroke:"#ffaa00"}});const s=Game.getObjectById(o);if(!s)return void e.say("â“ src gone");e.harvest(s)!==OK&&e.say("ðŸ’€ fail")}},hauler:new class extends E{run(e){if(this.updateWorkingState(e),e.memory.working){const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(o.length>0)return void(e.transfer(o[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o[0]))}const o=e.memory.containerId?Game.getObjectById(e.memory.containerId):null;o&&o.store[RESOURCE_ENERGY]>0?e.withdraw(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o):T(e)}}};exports.loop=function(){var o;!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`ðŸ§¹ Cleaned up memory for dead creep: ${e}`))}(),function(){if(Game.time%10==0)for(const e of Object.values(Game.rooms)){const o=n(e);for(const e of Object.keys(o)){const r=o[e],t=Object.values(Game.creeps).filter((o=>o.memory.role!==e&&(!o.memory.lockUntil||Game.time>=o.memory.lockUntil)&&f(o,e))),n={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const e of Object.values(Game.creeps))n[e.memory.role]=(n[e.memory.role]||0)+1;if(n[e]>=r)continue;const i=t.find((e=>{var r;const t=n[e.memory.role],i=null!==(r=o[e.memory.role])&&void 0!==r?r:0;return 0===i||t>i}));if(i){console.log(`ðŸ” ${i.name}: ${i.memory.role} â†’ ${e}`),i.memory.role=e,i.memory.lockUntil=Game.time+100;break}console.log(`âš ï¸ No reassignable creeps found for role '${e}'`),console.log(`  Needed: ${r}, Current: ${n[e]}`),console.log("  Candidates:",t.map((e=>`${e.name} (${e.memory.role})`)))}}}();const r=Object.values(Game.spawns)[0];r&&function(o){const r=n(o.room);Game.time%10==0&&console.log("demand:\n"+JSON.stringify(r,null,2));for(const t of Object.keys(r)){const n=r[t];if(Object.values(Game.creeps).filter((e=>e.memory.role===t)).length<n){const r=o.room.energyAvailable,n=s(t,r),i={harvester:"hr",builder:"b",upgrader:"u",miner:"m",hauler:"hl"},R=l(n),m=`${i[t]||t}_${R}_${Game.time}`;let u;if(t===e.Harvester||t===e.Miner){const r=t===e.Miner?1:2,i=a(o.room,t,r);if(!i){console.log("âŒ No available source for role"+t);continue}u=o.spawnCreep(n,m,{memory:{role:t,sourceId:i}}),u===OK&&console.log(`Spawning harvester: ${m} â†’ source ${i}`)}else if(t===e.Hauler){const e=c(o.room);if(!e){console.log("âŒ No available container for hauler");continue}u=o.spawnCreep(n,m,{memory:{role:t,containerId:e}}),u===OK&&console.log(`Spawning hauler: ${m} â†’ container ${e}`)}else u=o.spawnCreep(n,m,{memory:{role:t}}),u===OK&&console.log(`Spawning ${t}: ${m}`);if(u===OK)break}}}(r);for(const e of Object.values(Game.rooms))m(e);for(const e in Game.creeps){const r=Game.creeps[e],t=r.memory.role;null===(o=d[t])||void 0===o||o.run(r)}};
