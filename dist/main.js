"use strict";var e;function r(e){var r,o;const t=null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0;if(t<2)return 1;const n=e.find(FIND_SOURCES).length,s=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length,i=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length;return s<5||i<n?2:t<3?2.5:3===t?3:3.5}function o(e){const r={harvester:0,upgrader:0,builder:0,miner:0,hauler:0};for(const o of Object.values(Game.creeps)){if(o.room.name!==e.name)continue;const t=o.memory.role;void 0!==r[t]&&r[t]++}return r}function t(e){return e.memory.resourceStats&&e.memory.resourceStats.tickLastUpdated===Game.time||function(e){e.memory.resourceStats||(e.memory.resourceStats={energyInStructures:0,energyInPiles:0,energyInTransit:0,totalEnergy:0,energyAvailable:0,energyCapacityAvailable:0,tickLastUpdated:0});const r=e.memory.resourceStats,o=e.find(FIND_STRUCTURES).reduce(((e,r)=>"store"in r&&r.store.getUsedCapacity(RESOURCE_ENERGY)>0?e+r.store.getUsedCapacity(RESOURCE_ENERGY):e),0),t=e.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY}).reduce(((e,r)=>e+r.amount),0),n=e.find(FIND_MY_CREEPS).reduce(((e,r)=>{var o;return e+((null===(o=r.store)||void 0===o?void 0:o.getUsedCapacity(RESOURCE_ENERGY))||0)}),0),s=o+t+n;r.energyInStructures=o,r.energyInPiles=t,r.energyInTransit=n,r.totalEnergy=s,r.energyAvailable=e.energyAvailable,r.energyCapacityAvailable=e.energyCapacityAvailable,r.tickLastUpdated=Game.time}(e),e.memory.resourceStats}function n(e){const r=t(e);console.log(`📊 [${e.name}] Energy Stats:\n    ➡️  Available: ${r.energyAvailable} / ${r.energyCapacityAvailable}\n    🏦 In Structures: ${r.energyInStructures}\n    🪙 On Ground:     ${r.energyInPiles}\n    🚚 In Transit:    ${r.energyInTransit}\n    🔄 Total Energy:  ${r.totalEnergy}\n    (Updated tick: ${r.tickLastUpdated})\n    `)}Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e.Harvester="harvester",e.Upgrader="upgrader",e.Builder="builder",e.Miner="miner",e.Hauler="hauler"}(e||(e={}));const s=Object.values(e);function i(r){return r.find(FIND_SOURCES).every((o=>{const t=e=>e.room.name===r.name,n=e=>e.memory.sourceId===o.id;if(Object.values(Game.creeps).filter((r=>t(r)&&r.memory.role===e.Miner&&n(r))).length>=1)return!0;return Object.values(Game.creeps).filter((r=>t(r)&&r.memory.role===e.Harvester&&n(r))).length>=2}))}function a(e){const o=r(e),n=e.find(FIND_CONSTRUCTION_SITES).length,a=e.find(FIND_SOURCES),l=2*a.length,c=s.reduce(((e,r)=>(e[r]=0,e)),{}),R=t(e);R.totalEnergy;const m=R.energyInPiles;let u;switch(e.energyAvailable,o){case 1:u=Object.assign(Object.assign({},c),{harvester:l,upgrader:i(e)?1:0});break;case 2:const r=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});u=Object.assign(Object.assign({},c),{harvester:r.length>=1?l/2:l,builder:i(e)&&n>0?2:1,hauler:r.length>=1?1:0,miner:r.length>=1?1:0});break;case 2.5:u=Object.assign(Object.assign({},c),{miner:a.length,hauler:a.length,builder:i(e)?2:0,upgrader:i(e)&&n>0?0:10});break;default:u=Object.assign(Object.assign({},c),{miner:a.length,hauler:a.length,builder:i(e)?2:0,upgrader:i(e)&&n>0?0:6})}m>1e3&&(u.hauler=Math.min(3,u.hauler+1));const E=e.memory.roleDemandOverrides||{};for(const e of s)null!=E[e]&&(u[e]=E[e]);return u}Object.assign(Game,{setRoleDemandOverride:function(e,r,o){e.memory.roleDemandOverrides||(e.memory.roleDemandOverrides={}),e.memory.roleDemandOverrides[r]=o,console.log(`🔧 [${e.name}] override ${r} → ${o}`)},clearRoleDemandOverride:function(e,r){const o=e.memory.roleDemandOverrides;o&&null!=o[r]&&(delete o[r],console.log(`🗑️ [${e.name}] cleared override for ${r}`))},clearAllDemandOverrides:function(e){e.memory.roleDemandOverrides={},console.log(`🗑️ [${e.name}] cleared all role-demand overrides`)}});const l={harvester:{ratio:{work:3,carry:1,move:1},minEnergyForRatio:400,fallbackBody:[WORK,WORK,CARRY,MOVE]},miner:{ratio:{work:5,move:1},minEnergyForRatio:550,dontRepeatBody:!0},builder:{ratio:{work:2,carry:2,move:2},minEnergyForRatio:400,fallbackBody:[WORK,CARRY,CARRY,MOVE,MOVE]},upgrader:{ratio:{work:3,carry:2,move:3},minEnergyForRatio:550,fallbackBody:[WORK,WORK,CARRY,MOVE]},hauler:{ratio:{carry:6,move:3},minEnergyForRatio:450,fallbackBody:[CARRY,CARRY,CARRY,CARRY,MOVE,MOVE]}};function c(e){return e.reduce(((e,r)=>e+BODYPART_COST[r]),0)}function R(r){const t=r.room;!function(r){const t=a(r),n=o(r);r.memory.spawnQueue||(r.memory.spawnQueue=[]);const s=[],i=0===n[e.Miner];n[e.Hauler],n[e.Harvester];const l=r.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(i&&r.energyAvailable<=300)return console.log(`[${r.name}] 🚨 Emergency queue rebuild: only HARVESTER (no miners, low room energy)`),s.push({role:e.Harvester,timestamp:Game.time}),void(r.memory.spawnQueue=s);for(const r of[e.Miner,e.Hauler]){const e=n[r]||0,o=t[r]-e;if(o>0)for(let e=0;e<o;e++)s.push({role:r,timestamp:Game.time})}if(l.length>0||r.energyAvailable===r.energyCapacityAvailable)for(const r of[e.Upgrader,e.Builder]){const e=n[r]||0,o=t[r]-e;if(o>0)for(let e=0;e<o;e++)s.push({role:r,timestamp:Game.time})}else console.log(`[${r.name}] 🚫 Skipping upgraders/builders, economy not stable`);r.memory.spawnQueue=s,Game.time%10==0&&(console.log(`[${r.name}] ♻ Rebuilt queue: ${JSON.stringify(s)}`),console.log("demand",JSON.stringify(t)))}(t);const n=t.memory.spawnQueue;if(0===n.length)return;const s=n[0],i=function(r,o){const t=l[r];if(!t){console.log(`ERROR: No RoleConfig found for role: ${r}. Using default [W,C,M].`);const e=[WORK,CARRY,MOVE];return o>=c(e)?e:[]}const n=[],s=[];for(const[e,o]of Object.entries(t.ratio))if(void 0!==BODYPART_COST[e]){s.push(e);for(let r=0;r<o;r++)n.push(e)}else console.log(`ERROR: Invalid body part '${e}' in ratio for role ${r}`);const i=c(n);if(o<t.minEnergyForRatio||0===i){const n=t.fallbackBody||[];if(n.length>0&&o>=c(n))return n;let s=[WORK,CARRY,MOVE];return r===e.Miner&&(s=[WORK,MOVE]),o>=c(s)?s:[]}let a=[];if(t.dontRepeatBody)o>=i&&n.length<=50&&(a=[...n]);else{const e=Math.floor(o/i),r=n.length>0?Math.floor(50/n.length):0,t=Math.min(e,r);for(let e=0;e<t;e++)a.push(...n);let l=o-t*i;if(a.length<50){let e;do{e=!1;for(const r of s){const o=BODYPART_COST[r];if(l>=o&&a.length<50&&(a.push(r),l-=o,e=!0),a.length>=50)break}}while(e&&a.length<50)}}const R={[TOUGH]:1,[WORK]:2,[ATTACK]:3,[RANGED_ATTACK]:4,[CARRY]:5,[MOVE]:6,[HEAL]:7,[CLAIM]:8};return a.sort(((e,r)=>(R[e]||99)-(R[r]||99))),0===a.length&&t.fallbackBody&&o>=c(t.fallbackBody)?t.fallbackBody:a}(s.role,t.energyAvailable);if(0===i.length)return;const R=s.role,m=function(e){if(!e||0===e.length)return"empty";const r={};for(const o of e)r[o]=(r[o]||0)+1;return[TOUGH,WORK,CARRY,MOVE,ATTACK,RANGED_ATTACK,HEAL,CLAIM].filter((e=>r[e]&&r[e]>0)).map((e=>`${r[e]}${e[0]}`)).join("")}(i),u=`${{harvester:"hr",builder:"b",upgrader:"u",miner:"m",hauler:"hl"}[R]||R}_${m}_${Game.time}`;let E;if(R===e.Harvester||R===e.Miner){const o=R===e.Miner?1:2,t=function(e,r,o=2){const t=e.find(FIND_SOURCES),n={};for(const e of t)n[e.id]=0;for(const e of Object.values(Game.creeps))e.memory.role===r&&e.memory.sourceId&&(n[e.memory.sourceId]=(n[e.memory.sourceId]||0)+1);const s=t.find((e=>n[e.id]<o));return(null==s?void 0:s.id)||null}(r.room,R,o);if(!t)return void console.log(`❌ No available source for role ${R}`);E=r.spawnCreep(i,u,{memory:{role:R,sourceId:t}})}else if(R===e.Hauler){const e=function(e){const r=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER}),o={};for(const e of r)o[e.id]=0;for(const e of Object.values(Game.creeps))"hauler"===e.memory.role&&e.memory.containerId&&(o[e.memory.containerId]=(o[e.memory.containerId]||0)+1);const t=r.find((e=>o[e.id]<1));return(null==t?void 0:t.id)||null}(r.room);E=r.spawnCreep(i,u,{memory:{role:R,containerId:e}})}else E=r.spawnCreep(i,u,{memory:{role:R}});E===OK&&(console.log(`✅ Spawned ${R}: ${u}`),n.shift())}const m=[[0,-2],[1,-1],[2,0],[1,1],[0,2],[-1,1],[-2,0],[-1,-1]];function u(e){if(Game.time%10!=0)return;switch(r(e)){case 2:E(e),function(e){const r=e.find(FIND_MY_SPAWNS)[0];if(!r)return;e.memory.containerPositions||(e.memory.containerPositions={});for(const o of e.find(FIND_SOURCES)){const t=e.memory.containerPositions[o.id];if(t){const r=e.lookForAt(LOOK_STRUCTURES,t.x,t.y).some((e=>e.structureType===STRUCTURE_CONTAINER)),n=e.lookForAt(LOOK_CONSTRUCTION_SITES,t.x,t.y).some((e=>e.structureType===STRUCTURE_CONTAINER));if(r||n)continue;delete e.memory.containerPositions[o.id],console.log(`⚠️ Container for source ${o.id} missing, memory cleared`)}console.log("no memory of this source having a container",o);const n=y.map((([r,t])=>new RoomPosition(o.pos.x+r,o.pos.y+t,e.name))).filter((r=>e.getTerrain().get(r.x,r.y)!==TERRAIN_MASK_WALL&&(!(r.lookFor(LOOK_STRUCTURES).length>0)&&!(r.lookFor(LOOK_CONSTRUCTION_SITES).length>0))));if(0===n.length)continue;n.sort(((e,o)=>r.pos.getRangeTo(e)-r.pos.getRangeTo(o)));const s=n[0],i=e.createConstructionSite(s.x,s.y,STRUCTURE_CONTAINER);i===OK?(e.memory.containerPositions[o.id]={x:s.x,y:s.y},console.log(`✏️ Placed container for source ${o.id} at (${s.x},${s.y})`)):console.log(`❌ Failed to place container at (${s.x},${s.y}): ${i}`)}}(e);break;case 2.5:!function(e){var r;const o=e.find(FIND_MY_SPAWNS)[0],t=e.controller;if(!o||!t)return;if(!e.memory.roadSitesPlanned){const i=[];function a(e){for(const r of e)r.x,r.y,i.find((e=>e.x===r.x&&e.y===r.y))||i.push({x:r.x,y:r.y})}const l=e.find(FIND_SOURCES);for(const c of l){const R=null===(r=e.memory.containerPositions)||void 0===r?void 0:r[c.id];if(!R)continue;const m=new RoomPosition(R.x,R.y,e.name);a(PathFinder.search(m,{pos:o.pos,range:1},{plainCost:2,swampCost:10,roomCallback:e=>{const r=Game.rooms[e];if(!r)return!1;const o=new PathFinder.CostMatrix;return r.find(FIND_STRUCTURES).forEach((e=>{e.structureType===STRUCTURE_ROAD&&o.set(e.pos.x,e.pos.y,1)})),o}}).path)}a(PathFinder.search(o.pos,{pos:t.pos,range:3},{plainCost:2,swampCost:10}).path),e.memory.roadSitesPlanned=i}const n=e.memory.roadSitesPlanned;let s=0;for(const{x:u,y:E}of n){if(s>=5)break;const y=new RoomPosition(u,E,e.name);y.lookFor(LOOK_STRUCTURES).some((e=>e.structureType===STRUCTURE_ROAD))||y.lookFor(LOOK_CONSTRUCTION_SITES).some((e=>e.structureType===STRUCTURE_ROAD))||e.createConstructionSite(u,E,STRUCTURE_ROAD)===OK&&s++}}(e);break;case 3:E(e)}}function E(e){const r=e.controller;if(!r||!r.my||r.level<2)return;const o=CONTROLLER_STRUCTURES.extension[r.level]-(e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length+e.find(FIND_MY_CONSTRUCTION_SITES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}).length);if(o<=0)return;const t=e.find(FIND_MY_SPAWNS)[0];if(!t)return;let n=0;for(const[r,s]of m){if(n>=o)return;const i=t.pos.x+r,a=t.pos.y+s;if(!(e.lookForAt(LOOK_STRUCTURES,i,a).length>0||e.lookForAt(LOOK_CONSTRUCTION_SITES,i,a).length>0)){e.createConstructionSite(i,a,STRUCTURE_EXTENSION)===OK&&n++}}}const y=[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];class f{collectEnergy(e){const r=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(r)return void(e.pickup(r)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}}));const o=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(o.length>0){const r=e.pos.findClosestByPath(o);return void(r&&e.withdraw(r,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}}))}const t=e.room.find(FIND_SOURCES_ACTIVE);if(t.length>0){const r=e.pos.findClosestByPath(t);r&&e.harvest(r)===ERR_NOT_IN_RANGE&&e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}})}}updateWorkingState(e){e.memory.atCapacity&&0===e.store[RESOURCE_ENERGY]&&(e.memory.atCapacity=!1,e.say("🔄 harvest")),e.memory.atCapacity||0!==e.store.getFreeCapacity()||(e.memory.atCapacity=!0,e.say("⚡ deliver"))}deliverEnergy(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(r.length>0){const o=e.pos.findClosestByPath(r);o&&e.transfer(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}})}else e.say("🤷‍♂️ full?")}}function d(e){if(e.store.getFreeCapacity(RESOURCE_ENERGY)>0){const r=e.pos.findClosestByPath(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(r)return void(e.pickup(r)===ERR_NOT_IN_RANGE&&e.moveTo(r))}const r=e.room.find(FIND_CONSTRUCTION_SITES);if(r.length>0){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY)){const o=e.pos.findClosestByPath(r);return void(o&&e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o))}{const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0});if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}}const t=e.room.controller;if(t&&function(e){const r=a(e),t=o(e);for(const e of s)if(t[e]<r[e])return!1;return!0}(e.room)){const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store[RESOURCE_ENERGY]>0}),o=200;if(r.reduce(((e,r)=>e+r.store[RESOURCE_ENERGY]),0)>=o||e.room.energyAvailable>=o){if(0===e.store.getFreeCapacity(RESOURCE_ENERGY))return void(e.upgradeController(t)===ERR_NOT_IN_RANGE&&e.moveTo(t));if(r.length>0)return void(e.withdraw(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}}e.say("🪑 idle")}const T={[STRUCTURE_CONTAINER]:{pct:.8},[STRUCTURE_ROAD]:{pct:.5},[STRUCTURE_EXTENSION]:{pct:.8}};const S={harvester:new class extends f{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performDelivery(e):this.performHarvest(e)}performHarvest(e){let r=null;if(e.memory.sourceId&&(r=Game.getObjectById(e.memory.sourceId),r||(delete e.memory.sourceId,r=null)),!r){const o=e.room.find(FIND_SOURCES_ACTIVE);o.length>0&&(r=e.pos.findClosestByPath(o),r&&(e.memory.sourceId=r.id,e.say("🔄 New Src")))}if(r){const o=e.harvest(r);o===ERR_NOT_IN_RANGE?e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}}):o===OK||(o===ERR_NOT_ENOUGH_RESOURCES?(delete e.memory.sourceId,e.say("⛏️ Empty")):o===ERR_NO_BODYPART&&e.say("💔 No WORK"))}else e.say("❓ No Src"),d(e)}performDelivery(e){if(super.deliverEnergy(e),e.store.getUsedCapacity(RESOURCE_ENERGY)>0){e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0}).length>0||(e.say("🚚 IdleFull"),d(e))}}},builder:new class extends f{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performWork(e):super.collectEnergy(e)}performWork(e){this.tryPriorityRepair(e)||this.tryBuild(e)||this.tryGeneralRepair(e)||(e.say("👷 Idle"),d(e))}tryPriorityRepair(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)return!1;const r=T[e.structureType];return!!r&&(null!=r.pct&&e.hits<e.hitsMax*r.pct||null!=r.hp&&e.hits<r.hp)}});if(r.length>0){const o=e.pos.findClosestByPath(r);if(o)return e.say("🛠️ Prior"),e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ff0000"}}),!0}return!1}tryBuild(e){const r=e.room.find(FIND_CONSTRUCTION_SITES);if(r.length>0){const o=e.pos.findClosestByPath(r);if(o)return e.say("🚧 Build"),e.build(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffffff"}}),!0}return!1}tryGeneralRepair(e){const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_WALL&&e.structureType!==STRUCTURE_RAMPART&&e.hits<e.hitsMax});if(r.length>0){const o=e.pos.findClosestByPath(r);if(o)return e.say("🔧 Repair"),e.repair(o)===ERR_NOT_IN_RANGE&&e.moveTo(o,{visualizePathStyle:{stroke:"#ffaa00"}}),!0}return!1}},upgrader:new class extends f{run(e){this.updateWorkingState(e),e.memory.atCapacity?this.performUpgrade(e):super.collectEnergy(e)}performUpgrade(e){const r=e.room.controller;if(r&&r.my){const o=e.upgradeController(r);o===ERR_NOT_IN_RANGE?e.moveTo(r,{visualizePathStyle:{stroke:"#4CAF50"},range:3}):o===OK||(o===ERR_NOT_ENOUGH_RESOURCES?(e.memory.atCapacity=!1,e.say("⛏️ Empty!")):e.say(`⚠️ UpgErr ${o}`))}else e.say("❓ No Ctrlr"),d(e)}},miner:new class extends f{run(e){if(!this.hasValidAssignments(e))return;const{x:r,y:o}=e.room.memory.containerPositions[e.memory.sourceId],t=new RoomPosition(r,o,e.room.name);e.pos.isEqualTo(t)?this.performHarvesting(e):this.moveToDesignatedPosition(e,t)}hasValidAssignments(e){const r=e.memory.sourceId;if(!r)return e.say("❓NoSrcID"),console.log(`Miner ${e.name} is missing sourceId.`),!1;const o=e.room.memory.containerPositions;return!(!o||!o[r])||(e.say("❌NoSpot"),console.log(`Miner ${e.name} (source: ${r}) is missing a designated containerPosition in room memory.`),!1)}moveToDesignatedPosition(e,r){e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"},range:0})}performHarvesting(e){const r=Game.getObjectById(e.memory.sourceId);if(!r)return e.say("❓SrcGone"),console.log(`Miner ${e.name} assigned source ${e.memory.sourceId} no longer exists or is not visible.`),void delete e.memory.sourceId;const o=e.harvest(r);o===OK||(o===ERR_NOT_ENOUGH_RESOURCES?e.say("⛏️Empty"):o===ERR_BUSY||(o===ERR_NO_BODYPART?(e.say("💔NoWORK"),console.log(`Miner ${e.name} has no WORK parts.`)):o===ERR_NOT_OWNER?e.say("🏢NotMyCtrlr"):o===ERR_INVALID_TARGET?(e.say("❌InvTrg"),console.log(`Miner ${e.name} has invalid harvest target: ${r}`),delete e.memory.sourceId):(e.say(`💀HrvFail:${o}`),console.log(`Miner ${e.name} failed to harvest source ${r.id} with error: ${o}`))))}},hauler:new class extends f{run(e){if(this.updateWorkingState(e),e.memory.atCapacity){const r=e.room.find(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0});if(r.length>0)return void(e.transfer(r[0],RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(r[0]))}const r=e.memory.containerId,o=r?Game.getObjectById(r):null;o&&o.store.getUsedCapacity(RESOURCE_ENERGY)>0?e.withdraw(o,RESOURCE_ENERGY)===ERR_NOT_IN_RANGE&&e.moveTo(o):d(e)}}},C=function(e,r){const o=Game.cpu.getUsed(),t=r(),n=Game.cpu.getUsed()-o;return console.log(`📊 ${e}: ${n.toFixed(2)} CPU`),t}("main loop",(function(){!function(){for(const e in Memory.creeps)e in Game.creeps||(delete Memory.creeps[e],console.log(`🧹 Cleaned up memory for dead creep: ${e}`))}();const e=Object.values(Game.spawns)[0];e&&R(e);for(const e in Game.rooms){const r=Game.rooms[e];u(r),Game.time%10==0&&n(r)}for(const e in Game.creeps){const r=Game.creeps[e];if(!r.spawning){const e=r.memory.role;e&&S[e]?S[e].run(r):console.log(`Creep ${r.name} has an unknown or undefined role: ${e}`)}}}));exports.loop=C;
